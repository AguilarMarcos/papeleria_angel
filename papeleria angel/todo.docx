#auth_controller.py
from database import conectar
import hashlib

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def login(correo, contrase√±a):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor(dictionary=True)
    hashed_pass = hash_password(contrase√±a)
    
    query = "SELECT * FROM usuarios WHERE correo = %s AND contrase√±a = %s"
    cursor.execute(query, (correo, hashed_pass))
    usuario = cursor.fetchone()
    
    cursor.close()
    conn.close()
    
    if usuario:
        return True, usuario
    else:
        return False, "Correo o contrase√±a incorrectos"

def registrar_usuario(nombre, correo, contrase√±a, rol="cajero"):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor()
    hashed_pass = hash_password(contrase√±a)
    
    query = """
    INSERT INTO usuarios (nombre, correo, contrase√±a, rol)
    VALUES (%s, %s, %s, %s)
    """
    try:
        cursor.execute(query, (nombre, correo, hashed_pass, rol))
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Usuario registrado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al registrar: {str(e)}"
    

    # client_orders_controller.py
import mysql.connector
from database import conectar
from datetime import datetime
import logging

# Configuraci√≥n de logging (ajusta seg√∫n tu entorno)
logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)


def _safe_float(value, default=0.0):
    """Convierte cualquier valor a float, manejando None y cadenas."""
    try:
        return float(value) if value is not None else default
    except (ValueError, TypeError):
        return default


def _validar_fecha(fecha_str):
    """Valida y normaliza una fecha. Retorna YYYY-MM-DD o None."""
    if not fecha_str:
        return None
    try:
        # Acepta YYYY-MM-DD y tambi√©n YYYY/MM/DD
        fecha = datetime.strptime(fecha_str.strip(), "%Y-%m-%d")
        return fecha.strftime("%Y-%m-%d")
    except ValueError:
        try:
            fecha = datetime.strptime(fecha_str.strip(), "%Y/%m/%d")
            return fecha.strftime("%Y-%m-%d")
        except ValueError:
            return None


def _determinar_estado(total, abonado, tolerancia=0.01):
    """Determina el estado del pedido basado en total y abonado."""
    total = _safe_float(total)
    abonado = _safe_float(abonado)
    
    pendiente = round(total - abonado, 2)
    
    if pendiente <= tolerancia:  # ‚â§ 1 centavo
        return "Completado"
    elif abonado > 0:
        return "Abonado"
    else:
        return "Pendiente"


# =================================================================
# CRUD: Pedidos de Clientes (SIMPLIFICADO)
# =================================================================

def registrar_pedido_simple(cliente_id, usuario_id, total, abono_inicial=0.00, descripcion="", fecha_entrega_estimada=None):
    """Registra un nuevo pedido con total y abono inicial. Todo en una transacci√≥n."""
    conn = None
    cursor = None
    
    try:
        # Validaciones de entrada
        cliente_id = int(cliente_id)
        usuario_id = int(usuario_id)
        total = _safe_float(total)
        abono_inicial = _safe_float(abono_inicial)
        descripcion = str(descripcion).strip()[:500]  # L√≠mite de 500 chars
        fecha_entrega = _validar_fecha(fecha_entrega_estimada)

        if total <= 0:
            return False, "‚ùå El total del encargo debe ser mayor a cero."
        if abono_inicial < 0:
            return False, "‚ùå El abono inicial no puede ser negativo."
        if abono_inicial > total + 0.01:
            return False, f"‚ùå El abono inicial (${abono_inicial:.2f}) no puede superar el total (${total:.2f})."

        # Conexi√≥n
        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n a la base de datos."

        cursor = conn.cursor()

        # Fecha actual (solo fecha para el pedido, datetime para abonos)
        fecha_pedido = datetime.now().strftime('%Y-%m-%d')
        total_abonado = round(abono_inicial, 2)
        estado = _determinar_estado(total, total_abonado)

        # üîí Iniciar transacci√≥n expl√≠cita
        conn.start_transaction()

        # 1. Insertar pedido
        query_pedido = """
            INSERT INTO pedidos_cliente 
            (cliente_id, usuario_id, fecha_pedido, fecha_entrega_estimada, total, descripcion, total_abonado, estado)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        cursor.execute(query_pedido, (
            cliente_id, usuario_id, fecha_pedido, fecha_entrega,
            total, descripcion, total_abonado, estado
        ))
        pedido_id = cursor.lastrowid

        # 2. Registrar abono inicial (si > 0)
        if abono_inicial > 0:
            fecha_abono = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            query_abono = "INSERT INTO abonos (pedido_cliente_id, monto, fecha_abono) VALUES (%s, %s, %s)"
            cursor.execute(query_abono, (pedido_id, round(abono_inicial, 2), fecha_abono))

        # ‚úÖ Confirmar transacci√≥n
        conn.commit()
        return True, f"‚úÖ Encargo #{pedido_id} registrado. Total: ${total:.2f}. Abonado: ${abono_inicial:.2f}."

    except ValueError as ve:
        if conn:
            conn.rollback()
        logger.warning(f"Error de validaci√≥n al registrar pedido: {ve}")
        return False, "‚ùå Error: Los valores deben ser num√©ricos y v√°lidos."
    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        logger.error(f"Error MySQL al registrar pedido: {e}")
        return False, f"‚ùå Error al registrar encargo: {e.msg if hasattr(e, 'msg') else str(e)}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado al registrar pedido")
        return False, "‚ùå Error inesperado al registrar el encargo."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def obtener_pedidos_cliente():
    """Obtiene todos los pedidos activos con informaci√≥n completa del cliente y usuario."""
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return []

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT 
                pc.id,
                pc.fecha_pedido,
                pc.fecha_entrega_estimada,
                pc.total,
                pc.total_abonado,
                pc.estado,
                pc.descripcion,
                c.id AS cliente_id,
                c.nombre AS cliente_nombre,
                c.apellido AS cliente_apellido,
                c.telefono,
                u.id AS usuario_id,
                u.nombre AS usuario_nombre
            FROM pedidos_cliente pc
            INNER JOIN clientes c ON pc.cliente_id = c.id
            INNER JOIN usuarios u ON pc.usuario_id = u.id
            ORDER BY pc.fecha_pedido DESC, pc.id DESC
        """
        cursor.execute(query)
        pedidos = cursor.fetchall()

        # Procesar resultados
        for p in pedidos:
            # Combina nombre completo
            p['cliente_nombre_completo'] = f"{p['cliente_nombre']} {p['cliente_apellido']}".strip()
            # Convierte a float para c√°lculos seguros
            p['total'] = _safe_float(p['total'])
            p['total_abonado'] = _safe_float(p['total_abonado'])
            p['pendiente_pago'] = round(p['total'] - p['total_abonado'], 2)

        return pedidos

    except mysql.connector.Error as e:
        logger.error(f"Error MySQL al obtener pedidos: {e}")
        return []
    except Exception as e:
        logger.exception("Error inesperado al obtener pedidos")
        return []
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def registrar_abono(pedido_cliente_id, monto):
    conn = None
    cursor = None
    try:
        pedido_cliente_id = int(pedido_cliente_id)
        monto = _safe_float(monto)

        if monto <= 0:
            return False, "‚ùå El monto del abono debe ser mayor a cero."

        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n a la base de datos."

        cursor = conn.cursor(dictionary=True)

        # üîí Iniciar transacci√≥n
        conn.start_transaction()

        # 1. Obtener datos actuales del pedido
        cursor.execute("""
            SELECT id, total, total_abonado, estado
            FROM pedidos_cliente 
            WHERE id = %s AND estado != 'Cancelado'
            FOR UPDATE
        """, (pedido_cliente_id,))
        pedido = cursor.fetchone()

        if not pedido:
            return False, "‚ùå Pedido no encontrado o est√° cancelado."

        total = _safe_float(pedido['total'])
        total_abonado_actual = _safe_float(pedido['total_abonado'])
        nuevo_total_abonado = round(total_abonado_actual + monto, 2)

        # Validar l√≠mite
        if nuevo_total_abonado > total + 0.01:
            pendiente = round(total - total_abonado_actual, 2)
            return False, f"‚ùå El abono de ${monto:.2f} excede el saldo pendiente (${pendiente:.2f})."

        # 2. Insertar abono
        fecha_abono = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        cursor.execute("""
            INSERT INTO abonos (pedido_cliente_id, monto, fecha_abono)
            VALUES (%s, %s, %s)
        """, (pedido_cliente_id, round(monto, 2), fecha_abono))

        # 3. Actualizar pedido
        nuevo_estado = _determinar_estado(total, nuevo_total_abonado)
        cursor.execute("""
            UPDATE pedidos_cliente 
            SET total_abonado = %s, estado = %s 
            WHERE id = %s
        """, (nuevo_total_abonado, nuevo_estado, pedido_cliente_id))

        conn.commit()
        return True, f"‚úÖ Abono de ${monto:.2f} registrado. Estado: '{nuevo_estado}'."

    except ValueError:
        if conn:
            conn.rollback()
        return False, "‚ùå El monto debe ser un n√∫mero v√°lido."
    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        logger.error(f"Error MySQL al registrar abono: {e}")
        return False, f"‚ùå Error al registrar abono: {e.msg}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado al registrar abono")
        return False, "‚ùå Error inesperado al registrar el abono."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def obtener_abonos_pedido(pedido_id):
    """Obtiene el historial de abonos para un pedido espec√≠fico."""
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return []

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT monto, fecha_abono 
            FROM abonos 
            WHERE pedido_cliente_id = %s 
            ORDER BY fecha_abono ASC
        """
        cursor.execute(query, (int(pedido_id),))
        abonos = cursor.fetchall()
        
        # Asegurar formato de monto como float
        for a in abonos:
            a['monto'] = _safe_float(a['monto'])
        return abonos

    except Exception as e:
        logger.error(f"Error al obtener abonos del pedido {pedido_id}: {e}")
        return []
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def eliminar_pedido_cliente(pedido_id):
    """Elimina un pedido y sus abonos relacionados (hard delete)."""
    conn = None
    cursor = None
    try:
        pedido_id = int(pedido_id)
        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n a la base de datos."

        cursor = conn.cursor()

        # üîí Iniciar transacci√≥n
        conn.start_transaction()

        # 1. Verificar existencia y estado
        cursor.execute("SELECT id, estado FROM pedidos_cliente WHERE id = %s", (pedido_id,))
        pedido = cursor.fetchone()
        if not pedido:
            return False, "‚ùå Pedido no encontrado."

        # 2. Eliminar en orden inverso de dependencias
        cursor.execute("DELETE FROM abonos WHERE pedido_cliente_id = %s", (pedido_id,))
        cursor.execute("DELETE FROM detalle_pedido_cliente WHERE pedido_id = %s", (pedido_id,))
        cursor.execute("DELETE FROM pedidos_cliente WHERE id = %s", (pedido_id,))

        if cursor.rowcount == 0:
            conn.rollback()
            return False, "‚ùå No se pudo eliminar el pedido (puede estar bloqueado)."

        conn.commit()
        return True, f"‚úÖ Pedido #{pedido_id} y sus registros relacionados eliminados."

    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        logger.error(f"Error MySQL al eliminar pedido: {e}")
        return False, f"‚ùå Error al eliminar: {e.msg}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado al eliminar pedido")
        return False, "‚ùå Error inesperado durante la eliminaci√≥n."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()



            #client_orders_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime

import clientes_controller 
import client_orders_controller 


def validar_fecha(fecha_str):
    """Valida que la cadena tenga formato YYYY-MM-DD y sea una fecha v√°lida."""
    try:
        datetime.strptime(fecha_str, "%Y-%m-%d")
        return True
    except ValueError:
        return False


class ClientOrdersView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üìù Gesti√≥n de Pedidos a Clientes (Ventas a Cr√©dito)")
        self.root.geometry("1400x750")
        self.root.configure(bg="#f5f7fa")

        self.client_id_map = {}
        self.add_pedido_window = None
        self.abono_window = None
        self.abono_history_window = None

        # --- Estilos ---
        style = ttk.Style()
        style.configure("Treeview.Heading", font=("Arial", 11, "bold"), background="#d3e0e7", foreground="#2c3e50")
        style.configure("Treeview", font=("Arial", 10), rowheight=25)
        style.map("TButton", background=[("active", "#3498db")])
        style.configure("T.Blue.TButton", background="#3498db", foreground="white", font=("Arial", 10, "bold"))
        style.configure("T.Red.TButton", background="#e74c3c", foreground="white", font=("Arial", 10, "bold"))

        # --- Barra superior ---
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üìù Pedidos de Clientes (Abonos y Encargos)", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(root, text="‚Üê Volver al Dashboard", command=self.back_to_dashboard, bg="#6c757d", fg="white", font=("Arial", 10)).pack(anchor="nw", padx=20, pady=10)

        # --- Frame principal ---
        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # --- Tabla de pedidos ---
        list_frame = ttk.LabelFrame(main_frame, text="Listado de Pedidos a Clientes", padding="10")
        list_frame.pack(fill="both", expand=True, padx=10, pady=5)

        columns = ("ID", "Cliente", "Descripci√≥n", "Fecha Pedido", "Total", "Abonado", "Pendiente", "Estado")
        self.pedidos_tree = ttk.Treeview(list_frame, columns=columns, show="headings")

        for col in columns:
            self.pedidos_tree.heading(col, text=col)
            self.pedidos_tree.column(col, width=120, anchor=tk.CENTER)

        self.pedidos_tree.column("Cliente", width=200, anchor=tk.W)
        self.pedidos_tree.column("Descripci√≥n", width=250, anchor=tk.W)
        self.pedidos_tree.column("Total", width=100, anchor=tk.E)
        self.pedidos_tree.column("Abonado", width=100, anchor=tk.E)
        self.pedidos_tree.column("Pendiente", width=100, anchor=tk.E)

        # Tags para estados
        self.pedidos_tree.tag_configure('pendiente', background='#fcf8e3')  # Amarillo
        self.pedidos_tree.tag_configure('abonado', background='#d9edf7')    # Azul
        self.pedidos_tree.tag_configure('completado', background='#d4edda') # Verde
        self.pedidos_tree.tag_configure('cancelado', background='#f8d7da')  # Rojo

        self.pedidos_tree.pack(fill="both", expand=True)

        # --- Botones ---
        btn_frame = tk.Frame(main_frame, bg="#f5f7fa")
        btn_frame.pack(fill="x", pady=10, padx=10)
        ttk.Button(btn_frame, text="‚ûï Nuevo Pedido Cliente", command=self.open_add_pedido_window).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üíµ Registrar Abono", command=self.open_abono_window, style="T.Blue.TButton").pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üîç Ver Abonos", command=self.show_abonos).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="‚ùå Eliminar Pedido", command=self.delete_pedido_action, style="T.Red.TButton").pack(side="left", padx=5)

        self.load_pedidos()

    def load_pedidos(self):
        for item in self.pedidos_tree.get_children():
            self.pedidos_tree.delete(item)

        try:
            pedidos = client_orders_controller.obtener_pedidos_cliente()
            if pedidos is None:
                pedidos = []
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los pedidos:\n{e}", parent=self.root)
            return

        for p in pedidos:
            # ‚úÖ Redondeo expl√≠cito para evitar errores de punto flotante
            total = float(p['total'])
            abonado = float(p['total_abonado'])
            pendiente = round(total - abonado, 2)
            estado = p.get('estado', 'pendiente').lower()

            self.pedidos_tree.insert("", tk.END, values=(
                p['id'],
                p['cliente_nombre'],
                p['descripcion'] or 'N/A',
                p['fecha_pedido'],
                f"{total:.2f}",
                f"{abonado:.2f}",
                f"{pendiente:.2f}",
                p.get('estado', 'Pendiente')
            ), tags=(estado,))

    def _load_client_data(self):
        try:
            clientes = clientes_controller.obtener_todos_clientes()
            if clientes is None:
                clientes = []
            self.client_id_map = {f"{c['nombre']} {c['apellido']} (ID: {c['id']})": c['id'] for c in clientes}
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los clientes:\n{e}", parent=self.root)
            self.client_id_map = {}

    # ‚úÖ Nueva funci√≥n: verificar si una ventana est√° abierta y enfocarla
    def is_window_open(self, window_ref):
        return window_ref and window_ref.winfo_exists()

    def open_add_pedido_window(self):
        # üîí Evitar m√∫ltiples ventanas
        if self.is_window_open(self.add_pedido_window):
            self.add_pedido_window.focus()
            return

        self._load_client_data()
        if not self.client_id_map:
            messagebox.showerror("‚ùå Error", "No hay clientes registrados. Registre al menos uno primero.")
            return

        add_window = tk.Toplevel(self.root)
        self.add_pedido_window = add_window
        add_window.title("üìù Nuevo Encargo de Cliente (Abonos)")
        add_window.geometry("500x450")
        add_window.transient(self.root)
        add_window.grab_set()

        # ‚úÖ Limpieza al cerrar con X
        def on_close():
            self.add_pedido_window = None
            add_window.destroy()
        add_window.protocol("WM_DELETE_WINDOW", on_close)

        # --- Frame de datos ---
        input_frame = ttk.LabelFrame(add_window, text="Datos del Pedido", padding="10")
        input_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(input_frame, text="Cliente:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.cliente_var = tk.StringVar()
        cliente_combo = ttk.Combobox(input_frame, textvariable=self.cliente_var, values=list(self.client_id_map.keys()), state="readonly", width=30)
        cliente_combo.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        cliente_combo.current(0)

        ttk.Label(input_frame, text="Descripci√≥n (Maqueta/Encargo):").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.descripcion_entry = ttk.Entry(input_frame, width=30)
        self.descripcion_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")

        ttk.Label(input_frame, text="Fecha Entrega Estimada (YYYY-MM-DD):").grid(row=2, column=0, padx=5, pady=5, sticky="w")
        self.fecha_estimada_entry = ttk.Entry(input_frame, width=30)
        self.fecha_estimada_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")
        self.fecha_estimada_entry.insert(0, datetime.now().strftime('%Y-%m-%d'))

        # --- Frame financiero ---
        financial_frame = ttk.LabelFrame(add_window, text="Total y Abono Inicial", padding="10")
        financial_frame.pack(fill="x", padx=10, pady=10)

        ttk.Label(financial_frame, text="Precio Total del Encargo ($):").grid(row=0, column=0, padx=5, pady=10, sticky="w")
        self.total_encargo_entry = ttk.Entry(financial_frame, width=15)
        self.total_encargo_entry.grid(row=0, column=1, padx=5, pady=10, sticky="w")
        self.total_encargo_entry.insert(0, "0.00")

        ttk.Label(financial_frame, text="Monto de Abono Inicial ($):").grid(row=1, column=0, padx=5, pady=10, sticky="w")
        self.abono_inicial_entry = ttk.Entry(financial_frame, width=15)
        self.abono_inicial_entry.grid(row=1, column=1, padx=5, pady=10, sticky="w")
        self.abono_inicial_entry.insert(0, "0.00")

        # --- Bot√≥n ---
        ttk.Button(add_window, 
                   text="üíæ FINALIZAR Y REGISTRAR ENCARGO CON ABONO", 
                   command=self.final_register_pedido, 
                   style="T.Blue.TButton").pack(pady=20)

    def final_register_pedido(self):
        try:
            cliente_display = self.cliente_var.get().strip()
            if not cliente_display:
                messagebox.showerror("‚ùå Error", "Debe seleccionar un cliente.", parent=self.add_pedido_window)
                return

            # Sanitizar y convertir montos
            total_str = self.total_encargo_entry.get().replace(',', '.').strip()
            abono_str = self.abono_inicial_entry.get().replace(',', '.').strip()

            if not total_str or not abono_str:
                messagebox.showerror("‚ùå Error", "Complete los campos de Total y Abono.", parent=self.add_pedido_window)
                return

            total = float(total_str)
            abono_inicial = float(abono_str)

            if total <= 0:
                messagebox.showerror("‚ùå Error", "El precio total debe ser mayor a cero.", parent=self.add_pedido_window)
                return
            if abono_inicial < 0:
                messagebox.showerror("‚ùå Error", "El abono inicial no puede ser negativo.", parent=self.add_pedido_window)
                return
            if abono_inicial > total:
                messagebox.showerror("‚ùå Error", f"El abono (${abono_inicial:.2f}) no puede superar el total (${total:.2f}).", parent=self.add_pedido_window)
                return

            cliente_id = self.client_id_map.get(cliente_display)
            if not cliente_id:
                messagebox.showerror("‚ùå Error", "Cliente seleccionado inv√°lido.", parent=self.add_pedido_window)
                return

            fecha_entrega = self.fecha_estimada_entry.get().strip()
            if not validar_fecha(fecha_entrega):
                messagebox.showerror("‚ùå Error", "La fecha de entrega debe tener formato YYYY-MM-DD v√°lido.", parent=self.add_pedido_window)
                return

            descripcion = self.descripcion_entry.get().strip() or "Sin descripci√≥n"

            # üìû LLAMADA AL CONTROLADOR
            exito, mensaje = client_orders_controller.registrar_pedido_simple(
                cliente_id=cliente_id,
                usuario_id=self.usuario['id'],
                total=total,
                abono_inicial=abono_inicial,
                descripcion=descripcion,
                fecha_entrega=fecha_entrega
            )

            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje, parent=self.add_pedido_window)
                self.load_pedidos()
                self.add_pedido_window.destroy()
                self.add_pedido_window = None
            else:
                messagebox.showerror("‚ùå Error", mensaje, parent=self.add_pedido_window)

        except ValueError as ve:
            messagebox.showerror("‚ùå Error", "Aseg√∫rese de ingresar n√∫meros v√°lidos en Total y Abono.", parent=self.add_pedido_window)
        except Exception as e:
            messagebox.showerror("‚ùå Error Fatal", f"Error inesperado:\n{e}", parent=self.add_pedido_window)

    def open_abono_window(self):
        selected_item = self.pedidos_tree.focus()
        if not selected_item:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido para registrar un abono.")
            return

        values = self.pedidos_tree.item(selected_item, 'values')
        pedido_id = values[0]
        cliente_nombre = values[1]
        estado = values[7].lower()

        # üîí Bloquear abonos en pedidos cancelados/completados
        if estado in ('cancelado', 'completado'):
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", f"No se pueden registrar abonos a pedidos '{estado}'.", parent=self.root)
            return

        try:
            pendiente_pago = float(values[6])  # Columna "Pendiente"
        except (ValueError, IndexError):
            messagebox.showerror("‚ùå Error", "No se pudo leer el monto pendiente.")
            return

        if pendiente_pago <= 0:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", f"El pedido ya est√° cubierto (Pendiente: ${pendiente_pago:.2f}).", parent=self.root)
            return

        # üîí Evitar m√∫ltiples ventanas
        if self.is_window_open(self.abono_window):
            self.abono_window.focus()
            return

        abono_window = tk.Toplevel(self.root)
        self.abono_window = abono_window
        abono_window.title(f"üíµ Registrar Abono Pedido #{pedido_id}")
        abono_window.geometry("400x200")
        abono_window.transient(self.root)
        abono_window.grab_set()

        def on_close():
            self.abono_window = None
            abono_window.destroy()
        abono_window.protocol("WM_DELETE_WINDOW", on_close)

        frame = ttk.LabelFrame(abono_window, text=f"Abono para {cliente_nombre}", padding="10")
        frame.pack(padx=10, pady=10, fill="both", expand=True)

        ttk.Label(frame, text=f"Total Pendiente:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        ttk.Label(frame, text=f"${pendiente_pago:.2f}", font=("Arial", 10, "bold")).grid(row=0, column=1, padx=5, pady=5, sticky="w")

        ttk.Label(frame, text="Monto del Abono ($):").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.abono_monto_entry = ttk.Entry(frame, width=15)
        self.abono_monto_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        self.abono_monto_entry.insert(0, f"{min(pendiente_pago, 100.0):.2f}")  # Sugiere un valor razonable

        def registrar():
            try:
                monto_str = self.abono_monto_entry.get().replace(',', '.').strip()
                if not monto_str:
                    messagebox.showerror("‚ùå Error", "Ingrese un monto.", parent=abono_window)
                    return
                monto = float(monto_str)
                if monto <= 0:
                    messagebox.showerror("‚ùå Error", "El monto debe ser positivo.", parent=abono_window)
                    return
                if monto > pendiente_pago:
                    if not messagebox.askyesno("‚ùì Monto alto", 
                        f"El abono (${monto:.2f}) supera el pendiente (${pendiente_pago:.2f}).\n¬øDesea continuar? (Se ajustar√° a ${pendiente_pago:.2f})",
                        parent=abono_window):
                        return
                    monto = pendiente_pago

                exito, mensaje = client_orders_controller.registrar_abono(pedido_id, monto)
                if exito:
                    messagebox.showinfo("‚úÖ √âxito", mensaje, parent=abono_window)
                    self.load_pedidos()
                    abono_window.destroy()
                    self.abono_window = None
                else:
                    messagebox.showerror("‚ùå Error", mensaje, parent=abono_window)

            except ValueError:
                messagebox.showerror("‚ùå Error", "Monto inv√°lido. Use n√∫meros (ej. 25.50).", parent=abono_window)
            except Exception as e:
                messagebox.showerror("‚ùå Error", f"Error al registrar: {e}", parent=abono_window)

        ttk.Button(frame, text="üíæ Registrar Abono", command=registrar, style="T.Blue.TButton").grid(row=2, column=0, columnspan=2, pady=15)

    def show_abonos(self):
        selected_item = self.pedidos_tree.focus()
        if not selected_item:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido para ver el historial de abonos.")
            return

        pedido_id = self.pedidos_tree.item(selected_item, 'values')[0]
        cliente_nombre = self.pedidos_tree.item(selected_item, 'values')[1]

        # üîí Evitar m√∫ltiples ventanas
        if self.is_window_open(self.abono_history_window):
            self.abono_history_window.focus()
            return

        try:
            abonos = client_orders_controller.obtener_abonos_pedido(pedido_id)
            if abonos is None:
                abonos = []
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los abonos:\n{e}", parent=self.root)
            return

        if not abonos:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", f"No hay abonos registrados para el Pedido {pedido_id}.", parent=self.root)
            return

        hist_window = tk.Toplevel(self.root)
        self.abono_history_window = hist_window
        hist_window.title(f"Historial de Abonos Pedido #{pedido_id} - {cliente_nombre}")
        hist_window.geometry("400x300")
        hist_window.transient(self.root)
        hist_window.grab_set()

        def on_close():
            self.abono_history_window = None
            hist_window.destroy()
        hist_window.protocol("WM_DELETE_WINDOW", on_close)

        tree_frame = ttk.LabelFrame(hist_window, text="Detalle de Abonos", padding="10")
        tree_frame.pack(fill="both", expand=True, padx=10, pady=10)

        columns = ("Fecha", "Monto")
        abono_tree = ttk.Treeview(tree_frame, columns=columns, show="headings")
        for col in columns:
            abono_tree.heading(col, text=col)
            abono_tree.column(col, width=150, anchor=tk.CENTER)

        for a in abonos:
            abono_tree.insert("", tk.END, values=(a['fecha_abono'], f"${float(a['monto']):.2f}"))

        abono_tree.pack(fill="both", expand=True)

    def delete_pedido_action(self):
        selected_item = self.pedidos_tree.focus()
        if not selected_item:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido para eliminar.")
            return

        values = self.pedidos_tree.item(selected_item, 'values')
        pedido_id = values[0]
        cliente_nombre = values[1]
        estado = values[7].lower()

        if estado == "completado":
            msg = f"¬øEliminar pedido COMPLETADO #{pedido_id}?\n‚ö†Ô∏è Esta acci√≥n es irreversible y afecta registros contables."
        else:
            msg = f"¬øEliminar pedido #{pedido_id} de {cliente_nombre}?\nSe eliminar√°n tambi√©n todos los abonos."

        if not messagebox.askyesno("‚ùì Confirmar Eliminaci√≥n", msg, parent=self.root):
            return

        try:
            exito, mensaje = client_orders_controller.eliminar_pedido_cliente(pedido_id)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje, parent=self.root)
                self.load_pedidos()
            else:
                messagebox.showerror("‚ùå Error", mensaje, parent=self.root)
        except Exception as e:
            messagebox.showerror("‚ùå Error Fatal", f"Error al eliminar:\n{e}", parent=self.root)

    def back_to_dashboard(self):
        self.root.destroy()
        # ‚úÖ Recomendaci√≥n: en lugar de crear Tk() aqu√≠, deber√≠a ser gestionado por un AppManager
        # Pero para no romper tu flujo:
        try:
            from dashboard_view import DashboardView
            root = tk.Tk()
            DashboardView(root, self.usuario)
            root.mainloop()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo abrir el dashboard:\n{e}")



            # clientes_controller.py
from database import conectar
import re
import logging

# Configure logging
logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)

TABLE_NAME = "clientes"


def _sanitize_input(value):
    """Sanitiza entrada b√°sica (evita HTML/JS en datos)."""
    if not isinstance(value, str):
        return value
    # Elimina etiquetas HTML/JS (b√°sico)
    return re.sub(r'<[^>]+>', '', value).strip()


def _validate_client_data(nombre, telefono):
    """Validaci√≥n m√≠nima de datos esenciales."""
    nombre = _sanitize_input(nombre)
    if not nombre or len(nombre.strip()) < 2:
        return False, "El nombre debe tener al menos 2 caracteres."
    
    telefono = _sanitize_input(telefono)
    clean_phone = re.sub(r'\D', '', telefono)
    if len(clean_phone) < 10:
        return False, "El tel√©fono debe tener al menos 10 d√≠gitos."

    return True, ""


def add_client(nombre, apellido, telefono, direccion, email):
    """Inserta un nuevo cliente en la base de datos."""
    conexion = None
    cursor = None
    try:
        # ‚úÖ Validaci√≥n en capa de negocio
        valido, msg = _validate_client_data(nombre, telefono)
        if not valido:
            return False, f"‚ùå Datos inv√°lidos: {msg}"

        conexion = conectar()
        if not conexion:
            return False, "‚ùå Error: No se pudo conectar a la base de datos."

        cursor = conexion.cursor()

        # ‚úÖ Sanitizaci√≥n
        nombre = _sanitize_input(nombre)
        apellido = _sanitize_input(apellido or '')
        telefono = _sanitize_input(telefono)
        direccion = _sanitize_input(direccion or '')
        email = _sanitize_input(email or '').lower()

        # Validar email (b√°sico)
        if email and not re.match(r"[^@]+@[^@]+\.[^@]+", email):
            return False, "‚ùå El correo electr√≥nico tiene un formato inv√°lido."

        query = f"""
        INSERT INTO {TABLE_NAME} (nombre, apellido, telefono, direccion, email, fecha_registro)
        VALUES (%s, %s, %s, %s, %s, CURDATE())
        """
        cursor.execute(query, (nombre, apellido, telefono, direccion, email))
        conexion.commit()
        return True, f"‚úÖ Cliente '{nombre}' agregado con √©xito."

    except Exception as e:
        if conexion:
            conexion.rollback()
        logger.exception("Error al agregar cliente")
        return False, f"‚ùå Error al agregar cliente: {str(e)}"
    finally:
        if cursor:
            cursor.close()
        if conexion and conexion.is_connected():
            conexion.close()


def obtener_todos_clientes():
    """Obtiene todos los clientes (ordenados por nombre)."""
    conexion = None
    cursor = None
    try:
        conexion = conectar()
        if not conexion:
            return []

        cursor = conexion.cursor(dictionary=True)
        query = f"""
        SELECT id, nombre, apellido, telefono, direccion, email, fecha_registro
        FROM {TABLE_NAME}
        ORDER BY nombre, apellido
        """
        cursor.execute(query)
        return cursor.fetchall()
    except Exception as e:
        logger.error(f"Error al obtener clientes: {e}")
        return []
    finally:
        if cursor:
            cursor.close()
        if conexion and conexion.is_connected():
            conexion.close()


def update_client(client_id, nombre, apellido, telefono, direccion, email):
    """Actualiza un cliente existente."""
    conexion = None
    cursor = None
    try:
        if not client_id:
            return False, "‚ùå ID de cliente inv√°lido."

        valido, msg = _validate_client_data(nombre, telefono)
        if not valido:
            return False, f"‚ùå Datos inv√°lidos: {msg}"

        conexion = conectar()
        if not conexion:
            return False, "‚ùå Error de conexi√≥n."

        cursor = conexion.cursor()

        nombre = _sanitize_input(nombre)
        apellido = _sanitize_input(apellido or '')
        telefono = _sanitize_input(telefono)
        direccion = _sanitize_input(direccion or '')
        email = _sanitize_input(email or '').lower()

        if email and not re.match(r"[^@]+@[^@]+\.[^@]+", email):
            return False, "‚ùå Correo electr√≥nico inv√°lido."

        query = f"""
        UPDATE {TABLE_NAME}
        SET nombre = %s, apellido = %s, telefono = %s, direccion = %s, email = %s
        WHERE id = %s
        """
        cursor.execute(query, (nombre, apellido, telefono, direccion, email, client_id))

        if cursor.rowcount == 0:
            return False, "‚ùå Cliente no encontrado."

        conexion.commit()
        return True, f"‚úÖ Cliente '{nombre}' actualizado con √©xito."

    except Exception as e:
        if conexion:
            conexion.rollback()
        logger.exception("Error al actualizar cliente")
        return False, f"‚ùå Error al actualizar: {str(e)}"
    finally:
        if cursor:
            cursor.close()
        if conexion and conexion.is_connected():
            conexion.close()


def delete_client(client_id):
    """Elimina un cliente (soft delete recommended, but hard delete implemented)."""
    conexion = None
    cursor = None
    try:
        if not client_id:
            return False, "‚ùå ID de cliente inv√°lido."

        conexion = conectar()
        if not conexion:
            return False, "‚ùå Error de conexi√≥n."

        cursor = conexion.cursor()

        # üîí Opcional: verificar que no tenga pedidos/ventas (evita inconsistencia)
        cursor.execute("SELECT COUNT(*) FROM pedidos_cliente WHERE cliente_id = %s", (client_id,))
        tiene_pedidos = cursor.fetchone()[0] > 0

        if tiene_pedidos:
            return False, "‚ùå No se puede eliminar: el cliente tiene pedidos registrados."

        query = f"DELETE FROM {TABLE_NAME} WHERE id = %s"
        cursor.execute(query, (client_id,))

        if cursor.rowcount == 0:
            return False, "‚ùå Cliente no encontrado."

        conexion.commit()
        return True, "‚úÖ Cliente eliminado con √©xito."

    except Exception as e:
        if conexion:
            conexion.rollback()
        logger.exception("Error al eliminar cliente")
        return False, f"‚ùå Error al eliminar: {str(e)}"
    finally:
        if cursor:
            cursor.close()
        if conexion and conexion.is_connected():
            conexion.close()



            #clientes_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from clientes_controller import add_client, obtener_todos_clientes, update_client, delete_client
import re


class ClientsView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üë§ Gesti√≥n de Clientes - Papeler√≠a √Ångel")
        self.root.geometry("1150x680")
        self.root.configure(bg="#f5f7fa")
        self.root.minsize(900, 600)

        # Estado
        self.active_edit_window = None
        self.clients_data = []

        # --- Estilos ---
        style = ttk.Style()
        style.configure("Treeview.Heading", font=("Arial", 11, "bold"), background="#d3e0e7")
        style.configure("Treeview", font=("Arial", 10), rowheight=25)
        style.configure("T.Red.TButton", background="#e74c3c", foreground="white", font=("Arial", 10, "bold"))
        style.configure("T.Blue.TButton", background="#3498db", foreground="white", font=("Arial", 10, "bold"))

        # --- Barra superior ---
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üë§ Gesti√≥n de Clientes", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(root, text="‚Üê Volver al Dashboard", command=self.back_to_dashboard, bg="#6c757d", fg="white", font=("Arial", 10)).pack(anchor="nw", padx=20, pady=10)

        # --- Frame principal ---
        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # --- Formulario (izquierda) ---
        form_frame = ttk.LabelFrame(main_frame, text="Registrar Nuevo Cliente", padding="15")
        form_frame.pack(side="left", fill="y", padx=(0, 10))

        self.nombre_var = tk.StringVar()
        self.apellido_var = tk.StringVar()
        self.telefono_var = tk.StringVar()
        self.email_var = tk.StringVar()
        self.direccion_var = tk.StringVar()

        self._create_input_field(form_frame, "Nombre *:", self.nombre_var, 0)
        self._create_input_field(form_frame, "Apellido:", self.apellido_var, 1)
        self._create_input_field(form_frame, "Tel√©fono *:", self.telefono_var, 2)
        self._create_input_field(form_frame, "Email:", self.email_var, 3)
        self._create_input_field(form_frame, "Direcci√≥n:", self.direccion_var, 4)

        ttk.Button(
            form_frame,
            text="‚úÖ Agregar Cliente",
            command=self.add_client_action,
            style="T.Blue.TButton",
            width=25
        ).grid(row=5, column=0, columnspan=2, pady=20)

        # --- Tabla (derecha) ---
        table_frame = ttk.Frame(main_frame)
        table_frame.pack(side="right", fill="both", expand=True)

        # Barra de b√∫squeda (opcional pero √∫til)
        search_frame = ttk.Frame(table_frame)
        search_frame.pack(fill="x", pady=(0, 10))
        ttk.Label(search_frame, text="üîç Buscar:").pack(side="left", padx=(0, 5))
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        search_entry.pack(side="left")
        self.search_var.trace("w", lambda *args: self.filter_clients())

        # Tabla
        columns = ("ID", "Nombre", "Apellido", "Tel√©fono", "Email", "Direcci√≥n")
        self.clients_tree = ttk.Treeview(table_frame, columns=columns, show="headings")

        col_widths = {
            "ID": 50,
            "Nombre": 130,
            "Apellido": 120,
            "Tel√©fono": 110,
            "Email": 150,
            "Direcci√≥n": 180
        }
        for col in columns:
            self.clients_tree.heading(col, text=col)
            self.clients_tree.column(col, width=col_widths[col], anchor="w" if col in ("Nombre", "Apellido", "Direcci√≥n", "Email") else "center")

        # Scrollbars
        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.clients_tree.yview)
        hsb = ttk.Scrollbar(table_frame, orient="horizontal", command=self.clients_tree.xview)
        self.clients_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        self.clients_tree.pack(side="left", fill="both", expand=True)
        vsb.pack(side="right", fill="y")
        hsb.pack(side="bottom", fill="x")

        # Etiqueta vac√≠a
        self.empty_label = tk.Label(
            table_frame,
            text="üëã No hay clientes registrados.\nUse el formulario para agregar uno.",
            bg="#f5f7fa",
            fg="#7f8c8d",
            font=("Arial", 12, "italic")
        )
        self.empty_label.pack_forget()

        # Botones de acci√≥n
        btn_frame = tk.Frame(table_frame, bg="#f5f7fa")
        btn_frame.pack(pady=10)
        ttk.Button(btn_frame, text="‚úèÔ∏è Editar", command=self.edit_client_action, style="T.Blue.TButton").pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üóëÔ∏è Eliminar", command=self.delete_client_action, style="T.Red.TButton").pack(side="left", padx=5)

        # Cargar datos
        self.load_clients()

    def _create_input_field(self, parent, label_text, var, row):
        ttk.Label(parent, text=label_text).grid(row=row, column=0, padx=5, pady=8, sticky="w")
        entry = ttk.Entry(parent, textvariable=var, width=30)
        entry.grid(row=row, column=1, padx=5, pady=8)
        if "Tel√©fono" in label_text:
            entry.bind("<KeyRelease>", self._format_phone)
        return entry

    def _format_phone(self, event):
        """Formatea tel√©fono: 1234567890 ‚Üí (123) 456-7890"""
        val = self.telefono_var.get().replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        if val.isdigit() and len(val) >= 10:
            val = f"({val[:3]}) {val[3:6]}-{val[6:10]}"
        self.telefono_var.set(val[:14])  # M√°x 14 chars

    def _validate_inputs(self, nombre, telefono, email=""):
        """Valida datos antes de enviar."""
        if not nombre.strip():
            return False, "El nombre es obligatorio."
        if not telefono.strip():
            return False, "El tel√©fono es obligatorio."
        
        # Validar tel√©fono: debe tener 10+ d√≠gitos
        clean_phone = re.sub(r'\D', '', telefono)
        if len(clean_phone) < 10:
            return False, "El tel√©fono debe tener al menos 10 d√≠gitos."

        # Validar email (b√°sico)
        if email.strip() and not re.match(r"[^@]+@[^@]+\.[^@]+", email):
            return False, "El email tiene un formato inv√°lido."

        return True, ""

    def load_clients(self):
        """Carga clientes y actualiza UI."""
        try:
            self.clients_data = obtener_todos_clientes() or []
            self.filter_clients()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los clientes:\n{e}")

    def filter_clients(self, query=None):
        """Filtra clientes por b√∫squeda (case-insensitive)."""
        for item in self.clients_tree.get_children():
            self.clients_tree.delete(item)

        query = (self.search_var.get() or "").lower().strip()

        filtered = []
        for c in self.clients_data:
            # Busca en nombre, apellido, tel√©fono, email
            search_text = f"{c.get('nombre','')} {c.get('apellido','')} {c.get('telefono','')} {c.get('email','')}".lower()
            if query in search_text:
                filtered.append(c)

        if filtered:
            self.empty_label.pack_forget()
            for c in filtered:
                self.clients_tree.insert("", tk.END, values=(
                    c['id'],
                    c.get('nombre', ''),
                    c.get('apellido', ''),
                    c.get('telefono', ''),
                    c.get('email', ''),
                    c.get('direccion', '')
                ))
        else:
            self.clients_tree.pack_forget()
            self.empty_label.pack(pady=40)

    def add_client_action(self):
        nombre = self.nombre_var.get().strip()
        apellido = self.apellido_var.get().strip()
        telefono = self.telefono_var.get().strip()
        email = self.email_var.get().strip()
        direccion = self.direccion_var.get().strip()

        valido, mensaje = self._validate_inputs(nombre, telefono, email)
        if not valido:
            messagebox.showerror("‚ùå Validaci√≥n", mensaje)
            return

        try:
            exito, msg = add_client(nombre, apellido, telefono, email, direccion)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", msg)
                # ‚úÖ Solo limpiar si √©xito
                self.nombre_var.set("")
                self.apellido_var.set("")
                self.telefono_var.set("")
                self.email_var.set("")
                self.direccion_var.set("")
                self.load_clients()
                # Enfocar nombre para siguiente cliente
                self.root.focus_set()
            else:
                messagebox.showerror("‚ùå Error", msg)
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Error al registrar cliente:\n{e}")

    def edit_client_action(self):
        if self.active_edit_window:
            self.active_edit_window.focus()
            return

        selected = self.clients_tree.focus()
        if not selected:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un cliente para editar.")
            return

        values = self.clients_tree.item(selected, 'values')
        try:
            client_id = values[0]
            self.open_edit_window(
                client_id=client_id,
                nombre=values[1],
                apellido=values[2],
                telefono=values[3],
                email=values[4],
                direccion=values[5]
            )
        except IndexError:
            messagebox.showerror("‚ùå Error", "Datos del cliente incompletos.")

    def open_edit_window(self, client_id, nombre, apellido, telefono, email, direccion):
        if self.active_edit_window:
            self.active_edit_window.focus()
            return

        edit_window = tk.Toplevel(self.root)
        self.active_edit_window = edit_window
        edit_window.title(f"‚úèÔ∏è Editar Cliente ID: {client_id}")
        edit_window.geometry("450x380")
        edit_window.resizable(False, False)
        edit_window.grab_set()

        def on_close():
            self.active_edit_window = None
            edit_window.destroy()
        edit_window.protocol("WM_DELETE_WINDOW", on_close)

        frame = ttk.Frame(edit_window, padding="15")
        frame.pack(fill="both", expand=True)

        vars = {
            'nombre': tk.StringVar(value=nombre),
            'apellido': tk.StringVar(value=apellido),
            'telefono': tk.StringVar(value=telefono),
            'email': tk.StringVar(value=email),
            'direccion': tk.StringVar(value=direccion)
        }

        self._create_edit_field(frame, "Nombre *:", vars['nombre'], 0)
        self._create_edit_field(frame, "Apellido:", vars['apellido'], 1)
        tel_entry = self._create_edit_field(frame, "Tel√©fono *:", vars['telefono'], 2)
        tel_entry.bind("<KeyRelease>", self._format_phone)
        self._create_edit_field(frame, "Email:", vars['email'], 3)
        self._create_edit_field(frame, "Direcci√≥n:", vars['direccion'], 4)

        def save_changes():
            n = vars['nombre'].get().strip()
            a = vars['apellido'].get().strip()
            t = vars['telefono'].get().strip()
            e = vars['email'].get().strip()
            d = vars['direccion'].get().strip()

            valido, msg = self._validate_inputs(n, t, e)
            if not valido:
                messagebox.showerror("‚ùå Validaci√≥n", msg, parent=edit_window)
                return

            try:
                exito, mensaje = update_client(client_id, n, a, t, d, e)
                if exito:
                    messagebox.showinfo("‚úÖ √âxito", mensaje, parent=edit_window)
                    edit_window.destroy()
                    self.load_clients()
                else:
                    messagebox.showerror("‚ùå Error", mensaje, parent=edit_window)
            except Exception as ex:
                messagebox.showerror("‚ùå Error", f"Error al actualizar:\n{ex}", parent=edit_window)

        ttk.Button(
            frame,
            text="üíæ Guardar Cambios",
            command=save_changes,
            style="T.Blue.TButton",
            width=20
        ).grid(row=5, column=0, columnspan=2, pady=20)

    def _create_edit_field(self, parent, label_text, var, row):
        ttk.Label(parent, text=label_text).grid(row=row, column=0, padx=5, pady=8, sticky="w")
        entry = ttk.Entry(parent, textvariable=var, width=35)
        entry.grid(row=row, column=1, padx=5, pady=8)
        return entry

    def delete_client_action(self):
        selected = self.clients_tree.focus()
        if not selected:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un cliente para eliminar.")
            return

        values = self.clients_tree.item(selected, 'values')
        client_id, nombre = values[0], values[1]

        if not messagebox.askyesno(
            "‚ùì Confirmar eliminaci√≥n",
            f"¬øEliminar cliente '{nombre}' (ID: {client_id})?\n‚ö†Ô∏è Esta acci√≥n es irreversible.",
            parent=self.root
        ):
            return

        try:
            exito, mensaje = delete_client(client_id)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje)
                self.load_clients()
            else:
                messagebox.showerror("‚ùå Error", mensaje)
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Error al eliminar cliente:\n{e}")

    def back_to_dashboard(self):
        self.root.destroy()
        try:
            from dashboard_view import DashboardView
            root = tk.Tk()
            DashboardView(root, self.usuario)
            root.mainloop()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo abrir el dashboard:\n{e}")




            #Dashboard_View.py
import tkinter as tk
from tkinter import ttk, messagebox
import threading

# Importaciones inmediatas (seguras)
from products_view import ProductsView
from user_view import UserView
from suppliers_view import ProveedoresView
from sales_view import VentasView
from sales_history_view import SalesHistoryView


class DashboardView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.active_subwindow = None  # Track current subview
        self.loading_overlay = None

        self.root.title(f"üì¶ Papeler√≠a √Ångel - Dashboard | {usuario['nombre']}")
        self.root.geometry("1080x680")
        self.root.configure(bg="#f5f7fa")
        self.root.minsize(900, 600)

        # --- Header ---
        header = tk.Frame(root, bg="#2c3e50", height=80)
        header.pack(fill="x")

        tk.Label(
            header,
            text=f"üëã Bienvenido, {usuario['nombre']} ({usuario['rol'].capitalize()})",
            font=("Arial", 16, "bold"),
            fg="white",
            bg="#2c3e50"
        ).pack(side="left", padx=20, pady=20)

        tk.Button(
            header,
            text="üö™ Cerrar Sesi√≥n",
            command=self.logout,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief="flat",
            padx=10,
            width=12
        ).pack(side="right", padx=20, pady=20)

        # --- Content ---
        content = tk.Frame(root, bg="#f5f7fa")
        content.pack(fill="both", expand=True, padx=40, pady=30)

        # Configurar grid responsivo
        for i in range(2):  # 2 columnas
            content.grid_columnconfigure(i, weight=1)

        buttons = [
            ("üì¶ Productos", self.open_products, "#3498db"),
            ("üí∞ Ventas", self.show_sales, "#2ecc71"),
            ("üë• Clientes", self.open_clients, "#1abc9c"),
            ("üìù Pedidos Clientes (Abonos)", self.open_client_orders, "#f1c40f"),
            ("üìú Historial de Ventas", self.show_sales_history, "#f39c12")
        ]

        if usuario['rol'] == 'admin':
            buttons.extend([
                ("üè≠ Proveedores", self.open_suppliers, "#9b59b6"),
                ("üõí Pedidos / √ìrdenes de Compra", self.open_pedidos, "#2980b9"),
                ("‚öôÔ∏è Administraci√≥n de Usuarios", self.open_users, "#e67e22")
            ])

        # Crear botones
        for i, (text, command, color) in enumerate(buttons):
            btn = tk.Button(
                content,
                text=text,
                command=command,
                bg=color,
                fg="white",
                font=("Arial", 13, "bold"),
                height=2,
                relief="flat",
                activebackground=self._lighten_color(color),
                cursor="hand2"
            )
            # ‚úÖ Responsive: 2 columnas, centrado verticalmente
            row = i // 2
            col = i % 2
            btn.grid(row=row, column=col, padx=15, pady=12, sticky="ew")

        # --- Footer ---
        footer = tk.Label(
            root,
            text="Papeler√≠a √Ångel ¬© 2025 - Sistema de Gesti√≥n Digital",
            bg="#ecf0f1",
            fg="#7f8c8d",
            font=("Arial", 10)
        )
        footer.pack(side="bottom", fill="x", ipady=8)

    def _lighten_color(self, hex_color):
        """Clarear un color HEX para el estado 'active'."""
        hex_color = hex_color.lstrip('#')
        r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        r = min(255, r + 30)
        g = min(255, g + 30)
        b = min(255, b + 30)
        return f"#{r:02x}{g:02x}{b:02x}"

    def _show_loading(self):
        """Muestra overlay de carga sobre el dashboard."""
        if self.loading_overlay:
            return
        self.loading_overlay = tk.Toplevel(self.root)
        self.loading_overlay.geometry(self.root.geometry())
        self.loading_overlay.overrideredirect(True)
        self.loading_overlay.attributes("-alpha", 0.8)
        self.loading_overlay.configure(bg="white")

        tk.Label(
            self.loading_overlay,
            text="‚è≥ Cargando vista...\nPor favor, espere.",
            font=("Arial", 16),
            bg="white",
            fg="#2c3e50"
        ).place(relx=0.5, rely=0.5, anchor="center")

        # Centrar sobre dashboard
        self.root.update_idletasks()
        x = self.root.winfo_x()
        y = self.root.winfo_y()
        self.loading_overlay.geometry(f"+{x}+{y}")

    def _hide_loading(self):
        """Oculta el overlay de carga."""
        if self.loading_overlay:
            self.loading_overlay.destroy()
            self.loading_overlay = None

    def _open_view_safe(self, ViewClass, module_name=""):
        """Abre una vista de forma segura, con manejo de errores y limpieza."""
        if self.active_subwindow:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", "Ya hay una ventana abierta. Ci√©rrela primero.", parent=self.root)
            return

        # Mostrar carga
        self._show_loading()
        self.root.update_idletasks()

        def load_in_thread():
            try:
                # Cargar en segundo plano
                window = tk.Toplevel(self.root)
                window.title(f"{ViewClass.__name__} - Papeler√≠a √Ångel")
                window.geometry("1000x700")
                window.minsize(800, 500)

                # ‚úÖ Closure para limpieza espec√≠fica
                def on_close():
                    if window.winfo_exists():
                        window.destroy()
                    self.root.deiconify()
                    self.active_subwindow = None

                window.protocol("WM_DELETE_WINDOW", on_close)
                self.root.withdraw()
                self.active_subwindow = window

                # ‚úÖ Mostrar dashboard de nuevo si falla la vista
                try:
                    ViewClass(window, self.usuario)
                except Exception as e:
                    messagebox.showerror(
                        "‚ùå Error al cargar vista",
                        f"No se pudo abrir {module_name or ViewClass.__name__}:\n{e}",
                        parent=self.root
                    )
                    on_close()  # Restaurar dashboard

            except Exception as e:
                messagebox.showerror("‚ùå Error cr√≠tico", f"Fallo al crear ventana:\n{e}", parent=self.root)
                self.root.deiconify()
            finally:
                self.root.after(100, self._hide_loading)

        # Ejecutar en thread para no congelar UI
        threading.Thread(target=load_in_thread, daemon=True).start()

    # --- M√©todos de apertura ---
    def open_products(self):
        self._open_view_safe(ProductsView, "Productos")

    def open_users(self):
        self._open_view_safe(UserView, "Usuarios")

    def open_suppliers(self):
        self._open_view_safe(ProveedoresView, "Proveedores")

    def show_sales(self):
        self._open_view_safe(VentasView, "Ventas")

    def open_clients(self):
        try:
            from clientes_view import ClientsView
            self._open_view_safe(ClientsView, "Clientes")
        except ImportError as e:
            self._hide_loading()
            messagebox.showerror("‚ùå M√≥dulo faltante", f"No se encontr√≥ 'clientes_view.py':\n{e}")

    def open_client_orders(self):
        try:
            from client_orders_view import ClientOrdersView
            self._open_view_safe(ClientOrdersView, "Pedidos a Clientes")
        except ImportError as e:
            self._hide_loading()
            messagebox.showerror("‚ùå M√≥dulo faltante", f"No se encontr√≥ 'client_orders_view.py':\n{e}")

    def open_pedidos(self):
        try:
            from pedidos_view import PedidosView
            self._open_view_safe(PedidosView, "√ìrdenes de Compra")
        except ImportError as e:
            self._hide_loading()
            messagebox.showerror("‚ùå M√≥dulo faltante", f"No se encontr√≥ 'pedidos_view.py':\n{e}")

    def show_sales_history(self):
        self._open_view_safe(SalesHistoryView, "Historial de Ventas")

    def logout(self):
        if messagebox.askyesno("‚ùì Cerrar sesi√≥n", "¬øEst√° seguro que desea cerrar sesi√≥n?", parent=self.root):
            self.root.destroy()
            try:
                from login import LoginView
                root = tk.Tk()
                LoginView(root)
                root.mainloop()
            except Exception as e:
                messagebox.showerror("‚ùå Error", f"No se pudo abrir login:\n{e}")






                #database.py
import mysql.connector
from mysql.connector import Error

def conectar():
    try:
        conexion = mysql.connector.connect(
            host='localhost',
            database='papeleria_angel',
            user='root',
            password=''
        )
        if conexion.is_connected():
            print("‚úÖ Conexi√≥n exitosa a la base de datos")
            return conexion
    except Error as e:
        print(f"‚ùå Error al conectar: {e}")
        return None

def cerrar_conexion(conexion):
    if conexion and conexion.is_connected():
        conexion.close()
        print("üîå Conexi√≥n cerrada")





# login.py
import tkinter as tk
from tkinter import ttk, messagebox
from auth_controller import login, registrar_usuario

class LoginView:
    def __init__(self, root):
        self.root = root
        self.root.title("üîí Papeler√≠a √Ångel - Inicio de Sesi√≥n")
        self.root.geometry("420x520")
        self.root.resizable(False, False)
        self.root.configure(bg="#f5f7fa")

        # Marco principal
        main_frame = tk.Frame(root, bg="white", relief="groove", bd=1)
        main_frame.place(relx=0.5, rely=0.5, anchor="center", width=380, height=460)

        # T√≠tulo
        title_label = tk.Label(
            main_frame, 
            text="üîí Iniciar Sesi√≥n", 
            font=("Arial", 20, "bold"), 
            bg="white", 
            fg="#2c3e50"
        )
        title_label.pack(pady=(30, 20))

        # Formulario
        form_frame = tk.Frame(main_frame, bg="white")
        form_frame.pack(padx=30, pady=10)

        tk.Label(form_frame, text="Correo Electr√≥nico:", bg="white", font=("Arial", 11)).pack(anchor="w", pady=(10, 5))
        self.email_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.email_entry.pack(pady=5)
        self.email_entry.focus()

        tk.Label(form_frame, text="Contrase√±a:", bg="white", font=("Arial", 11)).pack(anchor="w", pady=(15, 5))
        self.password_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, show="*", relief="solid", bd=1)
        self.password_entry.pack(pady=5)

        # Botones
        btn_frame = tk.Frame(main_frame, bg="white")
        btn_frame.pack(pady=25)

        login_btn = tk.Button(
            btn_frame, 
            text="Iniciar Sesi√≥n", 
            command=self.login_user,
            bg="#3498db", 
            fg="white", 
            font=("Arial", 12, "bold"),
            width=15, 
            height=1,
            relief="flat",
            activebackground="#2980b9"
        )
        login_btn.pack(pady=5)

        register_btn = tk.Button(
            btn_frame, 
            text="Registrar Usuario", 
            command=self.show_register,
            bg="#95a5a6", 
            fg="white", 
            font=("Arial", 11),
            width=15, 
            height=1,
            relief="flat",
            activebackground="#7f8c8d"
        )
        register_btn.pack(pady=5)

        # Bot√≥n "Salir del Sistema"
        exit_btn = tk.Button(
            btn_frame, 
            text="üö™ Salir del Sistema", 
            command=self.salir_sistema,
            bg="#e74c3c", 
            fg="white", 
            font=("Arial", 11, "bold"),
            width=15, 
            height=1,
            relief="flat",
            activebackground="#c0392b"
        )
        exit_btn.pack(pady=5)

    def login_user(self):
        correo = self.email_entry.get().strip()
        contrase√±a = self.password_entry.get().strip()

        if not correo:
            messagebox.showwarning("‚ö†Ô∏è Campo vac√≠o", "Por favor, ingrese su correo electr√≥nico.")
            self.email_entry.focus()
            return
        if not contrase√±a:
            messagebox.showwarning("‚ö†Ô∏è Campo vac√≠o", "Por favor, ingrese su contrase√±a.")
            self.password_entry.focus()
            return

        if "@" not in correo or "." not in correo:
            messagebox.showerror("‚ùå Correo inv√°lido", "El correo electr√≥nico no tiene un formato v√°lido.")
            self.email_entry.focus()
            return

        success, data = login(correo, contrase√±a)
        if success:
            messagebox.showinfo("‚úÖ √âxito", f"¬°Bienvenido, {data['nombre']}!\nRol: {data['rol'].capitalize()}")
            self.root.destroy()
            from main import main
            main(data)
        else:
            messagebox.showerror("‚ùå Error de autenticaci√≥n", data)
            self.password_entry.delete(0, tk.END)
            self.password_entry.focus()

    def show_register(self):
        self.root.withdraw()
        register_window = tk.Toplevel(self.root)
        register_window.title("üìù Registrar Usuario - Papeler√≠a √Ångel")
        register_window.geometry("420x500")
        register_window.resizable(False, False)
        register_window.configure(bg="#f5f7fa")

        main_frame = tk.Frame(register_window, bg="white", relief="groove", bd=1)
        main_frame.place(relx=0.5, rely=0.5, anchor="center", width=380, height=440)

        tk.Label(main_frame, text="üìù Registro de Usuario", font=("Arial", 18, "bold"), bg="white", fg="#2c3e50").pack(pady=(25, 20))

        form_frame = tk.Frame(main_frame, bg="white")
        form_frame.pack(padx=25, pady=10)

        fields = [
            ("Nombre completo:", "name_entry"),
            ("Correo electr√≥nico:", "email_entry"),
            ("Contrase√±a:", "pass_entry"),
        ]

        entries = {}
        for label_text, attr in fields:
            tk.Label(form_frame, text=label_text, bg="white", font=("Arial", 11)).pack(anchor="w", pady=(8, 3))
            entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1, show="*" if "pass" in attr else "")
            entry.pack(pady=2)
            entries[attr] = entry

        tk.Label(form_frame, text="Rol:", bg="white", font=("Arial", 11)).pack(anchor="w", pady=(12, 3))
        role_var = tk.StringVar(value="cajero")
        role_combo = ttk.Combobox(form_frame, textvariable=role_var, values=["admin", "cajero"], state="readonly", width=28)
        role_combo.pack(pady=2)

        def register():
            nombre = entries["name_entry"].get().strip()
            correo = entries["email_entry"].get().strip()
            contrase√±a = entries["pass_entry"].get().strip()
            rol = role_var.get()

            if not nombre:
                messagebox.showwarning("‚ö†Ô∏è Nombre requerido", "El nombre completo es obligatorio.", parent=register_window)
                entries["name_entry"].focus()
                return
            if not correo or "@" not in correo:
                messagebox.showwarning("‚ö†Ô∏è Correo inv√°lido", "Ingrese un correo electr√≥nico v√°lido.", parent=register_window)
                entries["email_entry"].focus()
                return
            if len(contrase√±a) < 6:
                messagebox.showwarning("‚ö†Ô∏è Contrase√±a d√©bil", "La contrase√±a debe tener al menos 6 caracteres.", parent=register_window)
                entries["pass_entry"].focus()
                return

            success, msg = registrar_usuario(nombre, correo, contrase√±a, rol)
            if success:
                messagebox.showinfo("‚úÖ Registro exitoso", "Usuario creado correctamente.\nAhora puede iniciar sesi√≥n.", parent=register_window)
                register_window.destroy()
                self.root.deiconify()
            else:
                messagebox.showerror("‚ùå Error", msg, parent=register_window)

        btn_frame = tk.Frame(main_frame, bg="white")
        btn_frame.pack(pady=20)
        tk.Button(btn_frame, text="Registrar", command=register, bg="#2ecc71", fg="white", font=("Arial", 11, "bold"), width=12).pack(side="left", padx=5)
        tk.Button(btn_frame, text="Cancelar", command=lambda: [register_window.destroy(), self.root.deiconify()], bg="#e74c3c", fg="white", font=("Arial", 11, "bold"), width=12).pack(side="left", padx=5)

    def salir_sistema(self):
     if messagebox.askyesno("‚ùì Salir del sistema", "¬øEst√° seguro que desea salir de la aplicaci√≥n?"):
        self.root.destroy()
        exit(0)  # ‚Üê Cierra el proceso Python
     else:
        messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", "Se ha cancelado la salida del sistema.")






        #main.py
import tkinter as tk
from login import LoginView
def main(usuario_logueado=None):
    root = tk.Tk()
    if usuario_logueado:
        from dashboard_view import DashboardView
        DashboardView(root, usuario_logueado)
    else:
        LoginView(root)
    root.mainloop()
if __name__ == "__main__":
    main()



    # pedidos_controller.py
import mysql.connector
from database import conectar
from datetime import datetime
from decimal import Decimal
import logging

# Configuraci√≥n de logging (ajusta seg√∫n entorno)
logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)


def _safe_int(value, default=None):
    """Convierte a int de forma segura."""
    try:
        return int(value)
    except (ValueError, TypeError):
        return default


def _safe_decimal(value):
    """Convierte a Decimal para c√°lculos exactos."""
    try:
        return Decimal(str(value))
    except (ValueError, TypeError):
        return Decimal('0.00')


# =================================================================
# CRUD: √ìrdenes de Compra a Proveedores
# =================================================================

def registrar_pedido(proveedor_id, items, fecha_entrega_estimada=None):
    """Registra un nuevo pedido con sus √≠tems. Todo en una transacci√≥n."""
    conn = None
    cursor = None
    
    try:
        # Validaci√≥n de entrada
        proveedor_id = _safe_int(proveedor_id)
        if proveedor_id is None or proveedor_id <= 0:
            return False, "‚ùå Proveedor inv√°lido."

        if not items or not isinstance(items, list):
            return False, "‚ùå El pedido debe contener al menos un √≠tem."

        # Calcular total con Decimal para precisi√≥n
        total = sum(_safe_decimal(item.get('subtotal', 0)) for item in items)
        if total <= 0:
            return False, "‚ùå El total del pedido debe ser mayor a cero."

        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n a la base de datos."

        cursor = conn.cursor()

        # üîí Iniciar transacci√≥n expl√≠cita
        conn.start_transaction()

        # 1. Insertar cabecera del pedido
        fecha_pedido = datetime.now().strftime('%Y-%m-%d')
        cursor.execute("""
            INSERT INTO pedidos (proveedor_id, fecha_pedido, fecha_entrega_estimada, total, estado)
            VALUES (%s, %s, %s, %s, 'Pendiente')
        """, (proveedor_id, fecha_pedido, fecha_entrega_estimada, float(total)))

        pedido_id = cursor.lastrowid

        # 2. Insertar detalles
        detalle_data = []
        for item in items:
            producto_id = _safe_int(item.get('producto_id'))
            cantidad = _safe_int(item.get('cantidad', 0))
            precio_unitario = _safe_decimal(item.get('precio_unitario', 0))
            subtotal = _safe_decimal(item.get('subtotal', 0))

            if not producto_id or cantidad <= 0 or precio_unitario <= 0:
                raise ValueError(f"√çtem inv√°lido: ID={producto_id}, Cant={cantidad}, Precio={precio_unitario}")

            detalle_data.append((
                pedido_id,
                producto_id,
                cantidad,
                float(precio_unitario),
                float(subtotal)
            ))

        if detalle_data:
            cursor.executemany("""
                INSERT INTO detalle_pedido (pedido_id, producto_id, cantidad, precio_unitario, subtotal)
                VALUES (%s, %s, %s, %s, %s)
            """, detalle_data)

        # ‚úÖ Confirmar
        conn.commit()
        return True, f"‚úÖ Pedido #{pedido_id} registrado. Total: ${total:.2f}"

    except ValueError as ve:
        if conn:
            conn.rollback()
        logger.warning(f"Validaci√≥n fallida al registrar pedido: {ve}")
        return False, f"‚ùå Datos inv√°lidos: {ve}"
    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        logger.error(f"Error MySQL al registrar pedido: {e}")
        return False, f"‚ùå Error al registrar pedido: {e.msg}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado al registrar pedido")
        return False, "‚ùå Error inesperado. Consulte al administrador."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def obtener_pedidos():
    """Obtiene todos los pedidos con informaci√≥n del proveedor."""
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return []

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT 
                p.id, 
                pr.nombre_empresa AS proveedor, 
                p.fecha_pedido, 
                p.total, 
                p.estado,
                p.fecha_entrega_estimada
            FROM pedidos p
            INNER JOIN proveedores pr ON p.proveedor_id = pr.id
            ORDER BY p.fecha_pedido DESC, p.id DESC
        """
        cursor.execute(query)
        return cursor.fetchall()
    except mysql.connector.Error as e:
        logger.error(f"Error MySQL al obtener pedidos: {e}")
        return []
    except Exception as e:
        logger.exception("Error inesperado al obtener pedidos")
        return []
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def obtener_detalle_pedido(pedido_id):
    """Obtiene los √≠tems de un pedido espec√≠fico."""
    conn = None
    cursor = None
    try:
        pedido_id = _safe_int(pedido_id)
        if not pedido_id:
            return []

        conn = conectar()
        if not conn:
            return []

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT 
                dp.producto_id, 
                pr.nombre AS producto_nombre,
                dp.cantidad, 
                dp.precio_unitario, 
                dp.subtotal
            FROM detalle_pedido dp
            INNER JOIN productos pr ON dp.producto_id = pr.id
            WHERE dp.pedido_id = %s
            ORDER BY pr.nombre ASC
        """
        cursor.execute(query, (pedido_id,))
        return cursor.fetchall()
    except Exception as e:
        logger.error(f"Error al obtener detalle del pedido {pedido_id}: {e}")
        return []
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def obtener_pedido_por_id(pedido_id):
    """Obtiene un pedido completo por ID, incluyendo nombre del proveedor."""
    conn = None
    cursor = None
    try:
        pedido_id = _safe_int(pedido_id)
        if not pedido_id:
            return None

        conn = conectar()
        if not conn:
            return None

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT p.*, pr.nombre_empresa AS proveedor_nombre
            FROM pedidos p
            INNER JOIN proveedores pr ON p.proveedor_id = pr.id
            WHERE p.id = %s
        """
        cursor.execute(query, (pedido_id,))
        return cursor.fetchone()
    except Exception as e:
        logger.error(f"Error al obtener pedido {pedido_id}: {e}")
        return None
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def actualizar_estado_pedido(pedido_id, nuevo_estado):
    """Actualiza el estado de un pedido. Si es 'Recibido', actualiza stock en la misma transacci√≥n."""
    conn = None
    cursor = None
    try:
        pedido_id = _safe_int(pedido_id)
        if not pedido_id:
            return False, "‚ùå ID de pedido inv√°lido."

        if nuevo_estado not in ['Pendiente', 'Recibido', 'Cancelado']:
            return False, "‚ùå Estado no v√°lido."

        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n a la base de datos."

        cursor = conn.cursor(dictionary=True)

        # üîí Iniciar transacci√≥n
        conn.start_transaction()

        # 1. Obtener estado actual y validar
        cursor.execute("""
            SELECT id, estado, proveedor_id FROM pedidos WHERE id = %s FOR UPDATE
        """, (pedido_id,))
        pedido = cursor.fetchone()

        if not pedido:
            return False, "‚ùå Pedido no encontrado."

        estado_actual = pedido['estado']
        if estado_actual == nuevo_estado:
            return True, f"‚ÑπÔ∏è El pedido ya est√° en estado '{nuevo_estado}'."

        if estado_actual == 'Recibido' and nuevo_estado == 'Recibido':
            return False, "‚ùå El pedido ya fue recibido. No se puede procesar doblemente."

        # 2. Actualizar estado
        cursor.execute("""
            UPDATE pedidos SET estado = %s WHERE id = %s
        """, (nuevo_estado, pedido_id))

        # 3. Si es 'Recibido', actualizar stock
        if nuevo_estado == 'Recibido':
            # üî¥ ¬°Importante! Obtener detalles EN LA MISMA CONEXI√ìN y transacci√≥n
            cursor.execute("""
                SELECT producto_id, cantidad 
                FROM detalle_pedido 
                WHERE pedido_id = %s
            """, (pedido_id,))
            items = cursor.fetchall()

            if not items:
                logger.warning(f"Pedido {pedido_id} marcado como recibido sin √≠tems.")

            for item in items:
                cursor.execute("""
                    UPDATE productos
                    SET stock = stock + %s
                    WHERE id = %s
                """, (item['cantidad'], item['producto_id']))

        # ‚úÖ Confirmar
        conn.commit()
        return True, f"‚úÖ Pedido #{pedido_id} actualizado a '{nuevo_estado}'."

    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        logger.error(f"Error MySQL al actualizar estado: {e}")
        return False, f"‚ùå Error al actualizar estado: {e.msg}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado al actualizar estado")
        return False, "‚ùå Error inesperado. Consulte al administrador."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def update_pedido_details(pedido_id, proveedor_id, fecha_entrega_estimada):
    """Actualiza proveedor y fecha estimada de un pedido (solo si est√° 'Pendiente')."""
    conn = None
    cursor = None
    try:
        pedido_id = _safe_int(pedido_id)
        proveedor_id = _safe_int(proveedor_id)
        
        if not pedido_id or not proveedor_id:
            return False, "‚ùå Datos inv√°lidos."

        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n."

        cursor = conn.cursor()

        # Solo permitir edici√≥n si el pedido est√° pendiente
        cursor.execute("""
            UPDATE pedidos 
            SET proveedor_id = %s, fecha_entrega_estimada = %s
            WHERE id = %s AND estado = 'Pendiente'
        """, (proveedor_id, fecha_entrega_estimada, pedido_id))

        if cursor.rowcount == 0:
            return False, "‚ùå Pedido no encontrado o ya no es editable (debe estar 'Pendiente')."

        conn.commit()
        return True, f"‚úÖ Pedido #{pedido_id} actualizado."

    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        return False, f"‚ùå Error al actualizar: {e.msg}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado en update_pedido_details")
        return False, "‚ùå Error inesperado."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


def eliminar_pedido(pedido_id):
    """Elimina un pedido y sus detalles (solo si est√° 'Pendiente' o 'Cancelado')."""
    conn = None
    cursor = None
    try:
        pedido_id = _safe_int(pedido_id)
        if not pedido_id:
            return False, "‚ùå ID inv√°lido."

        conn = conectar()
        if not conn:
            return False, "‚ùå Error de conexi√≥n."

        cursor = conn.cursor()

        # üîí Solo eliminar pedidos no recibidos (evita inconsistencia de stock)
        cursor.execute("""
            DELETE dp, p 
            FROM pedidos p
            LEFT JOIN detalle_pedido dp ON p.id = dp.pedido_id
            WHERE p.id = %s AND p.estado IN ('Pendiente', 'Cancelado')
        """, (pedido_id,))

        if cursor.rowcount == 0:
            return False, "‚ùå Pedido no encontrado o ya fue recibido (no se puede eliminar)."

        conn.commit()
        return True, f"‚úÖ Pedido #{pedido_id} eliminado."

    except mysql.connector.Error as e:
        if conn:
            conn.rollback()
        logger.error(f"Error al eliminar pedido {pedido_id}: {e}")
        return False, f"‚ùå Error al eliminar: {e.msg}"
    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error inesperado al eliminar pedido")
        return False, "‚ùå Error inesperado."
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()




            #pedidos_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime

# IMPORTS CENTRALES
from pedidos_controller import (
    obtener_pedidos, obtener_detalle_pedido, registrar_pedido,
    actualizar_estado_pedido, eliminar_pedido,
    obtener_pedido_por_id, update_pedido_details
)
import suppliers_controller
import products_controller


def validar_fecha(fecha_str):
    """Valida y normaliza fecha en formato YYYY-MM-DD."""
    if not fecha_str:
        return None
    try:
        return datetime.strptime(fecha_str.strip(), "%Y-%m-%d").strftime("%Y-%m-%d")
    except ValueError:
        return None


class PedidosView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üõí Gesti√≥n de Pedidos (√ìrdenes de Compra)")
        self.root.geometry("1300x700")
        self.root.configure(bg="#f5f7fa")

        # Estado de ventanas abiertas
        self.add_pedido_window = None
        self.edit_pedido_window = None
        self.detail_window = None

        # Cach√© de datos (carga una vez)
        self.proveedor_id_map = {}
        self.product_map = {}
        self._load_all_data()  # ‚Üê Carga inicial

        # --- Estilos ---
        style = ttk.Style()
        style.configure("Treeview.Heading", font=("Arial", 11, "bold"), background="#d3e0e7", foreground="#2c3e50")
        style.configure("Treeview", font=("Arial", 10), rowheight=25)
        style.map("TButton", background=[("active", "#3498db")])
        style.configure("T.Blue.TButton", background="#3498db", foreground="white", font=("Arial", 10, "bold"))
        style.configure("T.Red.TButton", background="#e74c3c", foreground="white", font=("Arial", 10, "bold"))

        # --- Barra superior ---
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üõí √ìrdenes de Compra a Proveedores", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(root, text="‚Üê Volver al Dashboard", command=self.back_to_dashboard, bg="#6c757d", fg="white", font=("Arial", 10)).pack(anchor="nw", padx=20, pady=10)

        # --- Frame principal ---
        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # --- Tabla de pedidos ---
        list_frame = ttk.LabelFrame(main_frame, text="Listado de √ìrdenes", padding="10")
        list_frame.pack(fill="both", expand=True, padx=10, pady=5)

        columns = ("ID", "Proveedor", "Fecha Pedido", "Total", "Estado")
        self.pedidos_tree = ttk.Treeview(list_frame, columns=columns, show="headings")
        for col in columns:
            self.pedidos_tree.heading(col, text=col)
            self.pedidos_tree.column(col, width=150, anchor=tk.CENTER)
        self.pedidos_tree.column("Proveedor", width=250, anchor=tk.W)
        self.pedidos_tree.pack(fill="both", expand=True)

        # Tags de estado
        self.pedidos_tree.tag_configure('pendiente', background='#fcf8e3')  # Amarillo
        self.pedidos_tree.tag_configure('recibido', background='#d4edda')   # Verde
        self.pedidos_tree.tag_configure('cancelado', background='#f8d7da')  # Rojo

        # --- Botones ---
        btn_frame = tk.Frame(main_frame, bg="#f5f7fa")
        btn_frame.pack(fill="x", pady=10, padx=10)
        ttk.Button(btn_frame, text="‚ûï Nuevo Pedido", command=self.open_add_pedido_window).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üîç Ver Detalle", command=self.show_detalle_pedido).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="‚úèÔ∏è Editar Pedido", command=self.open_edit_pedido_window).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üîÑ Marcar como Recibido", command=lambda: self.update_status('Recibido')).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="‚ùå Eliminar Pedido", command=self.delete_pedido_action, style="T.Red.TButton").pack(side="left", padx=5)

        self.load_pedidos()

    def _load_all_data(self):
        """Carga proveedores y productos una sola vez (al inicio)."""
        try:
            # Proveedores
            proveedores = suppliers_controller.obtener_todos_proveedores() or []
            self.proveedor_id_map = {p['nombre_empresa']: p['id'] for p in proveedores}
            if not self.proveedor_id_map:
                print("‚ö†Ô∏è Advertencia: No se encontraron proveedores.")

            # Productos
            productos = products_controller.get_all_products() or []
            self.product_map = {}
            for p in productos:
                key = f"{p['nombre']} (ID: {p['id']})"
                self.product_map[key] = {
                    'id': p['id'],
                    'precio_compra': float(p.get('precio_compra', 0)),
                    'stock_actual': p.get('stock', 0)
                }
            if not self.product_map:
                print("‚ö†Ô∏è Advertencia: No se encontraron productos.")
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar datos maestros:\n{e}")

    def is_window_open(self, window_ref):
        """Verifica si una ventana Toplevel est√° abierta."""
        return window_ref and window_ref.winfo_exists()

    def load_pedidos(self):
        for item in self.pedidos_tree.get_children():
            self.pedidos_tree.delete(item)

        try:
            pedidos = obtener_pedidos() or []
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los pedidos:\n{e}")
            return

        for p in pedidos:
            estado = str(p.get('estado', 'Pendiente')).lower()
            self.pedidos_tree.insert("", tk.END, values=(
                p['id'],
                p.get('proveedor', '‚Äî') or '‚Äî',
                p.get('fecha_pedido', '‚Äî'),
                f"${p.get('total', 0):.2f}",
                p.get('estado', 'Pendiente')
            ), tags=(estado,))

    def show_detalle_pedido(self):
        if self.is_window_open(self.detail_window):
            self.detail_window.focus()
            return

        selected_item = self.pedidos_tree.focus()
        if not selected_item:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido para ver el detalle.")
            return

        pedido_id = self.pedidos_tree.item(selected_item, 'values')[0]
        try:
            detalle = obtener_detalle_pedido(pedido_id) or []
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo cargar el detalle:\n{e}")
            return

        if not detalle:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", f"El pedido {pedido_id} no tiene productos registrados.")
            return

        detail_window = tk.Toplevel(self.root)
        self.detail_window = detail_window
        detail_window.title(f"üîç Detalle del Pedido #{pedido_id}")
        detail_window.geometry("650x400")
        detail_window.transient(self.root)
        detail_window.grab_set()

        def on_close():
            self.detail_window = None
            detail_window.destroy()
        detail_window.protocol("WM_DELETE_WINDOW", on_close)

        frame = ttk.LabelFrame(detail_window, text=f"Productos en Pedido #{pedido_id}", padding="10")
        frame.pack(fill="both", expand=True, padx=10, pady=10)

        columns = ("ID", "Nombre", "Cantidad", "Precio Unit.", "Subtotal")
        tree = ttk.Treeview(frame, columns=columns, show="headings")
        for col in columns:
            tree.heading(col, text=col)
            tree.column(col, width=100, anchor=tk.CENTER)
        tree.column("Nombre", width=200, anchor=tk.W)

        for d in detalle:
            tree.insert("", tk.END, values=(
                d.get('producto_id', '‚Äî'),
                d.get('producto_nombre', '‚Äî'),
                d.get('cantidad', 0),
                f"${d.get('precio_unitario', 0):.2f}",
                f"${d.get('subtotal', 0):.2f}"
            ))

        tree.pack(fill="both", expand=True)
        detail_window.wait_window()

    def open_add_pedido_window(self):
        if self.is_window_open(self.add_pedido_window):
            self.add_pedido_window.focus()
            return

        if not self.proveedor_id_map:
            messagebox.showerror("‚ùå Error", "No hay proveedores registrados. Registre al menos uno.")
            return
        if not self.product_map:
            messagebox.showerror("‚ùå Error", "No hay productos registrados. Registre al menos uno.")
            return

        add_window = tk.Toplevel(self.root)
        self.add_pedido_window = add_window
        add_window.title("‚ûï Nuevo Pedido de Compra")
        add_window.geometry("850x600")
        add_window.transient(self.root)
        add_window.grab_set()

        def on_close():
            self.add_pedido_window = None
            add_window.destroy()
        add_window.protocol("WM_DELETE_WINDOW", on_close)

        self.new_pedido_items = []

        # --- Datos generales ---
        input_frame = ttk.LabelFrame(add_window, text="Datos del Pedido", padding="10")
        input_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(input_frame, text="Proveedor: *").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.proveedor_var = tk.StringVar()
        combo_prov = ttk.Combobox(input_frame, textvariable=self.proveedor_var, values=list(self.proveedor_id_map.keys()), state="readonly", width=40)
        combo_prov.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        combo_prov.current(0)

        ttk.Label(input_frame, text="Fecha Entrega Estimada (YYYY-MM-DD): *").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.fecha_estimada_entry = ttk.Entry(input_frame, width=30)
        self.fecha_estimada_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        self.fecha_estimada_entry.insert(0, datetime.now().strftime('%Y-%m-%d'))

        # --- A√±adir productos ---
        product_frame = ttk.LabelFrame(add_window, text="A√±adir Productos", padding="10")
        product_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(product_frame, text="Producto: *").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.producto_var = tk.StringVar()
        self.producto_combobox = ttk.Combobox(product_frame, textvariable=self.producto_var, values=list(self.product_map.keys()), state="readonly", width=35)
        self.producto_combobox.grid(row=0, column=1, padx=5, pady=5, sticky="w")

        # ‚úÖ Autocompletar precio al seleccionar producto
        def on_product_select(event):
            prod_key = self.producto_var.get()
            prod = self.product_map.get(prod_key)
            if prod:
                self.precio_unitario_entry.delete(0, tk.END)
                self.precio_unitario_entry.insert(0, f"{prod['precio_compra']:.2f}")
                # Opcional: mostrar stock actual
                self.stock_label.config(text=f"Stock actual: {prod['stock_actual']}")
        self.producto_combobox.bind("<<ComboboxSelected>>", on_product_select)

        ttk.Label(product_frame, text="Cantidad: *").grid(row=0, column=2, padx=5, pady=5, sticky="w")
        self.cantidad_entry = ttk.Entry(product_frame, width=10)
        self.cantidad_entry.grid(row=0, column=3, padx=5, pady=5, sticky="w")
        self.cantidad_entry.insert(0, "1")

        ttk.Label(product_frame, text="Precio Unit. Compra ($): *").grid(row=0, column=4, padx=5, pady=5, sticky="w")
        self.precio_unitario_entry = ttk.Entry(product_frame, width=15)
        self.precio_unitario_entry.grid(row=0, column=5, padx=5, pady=5, sticky="w")

        self.stock_label = ttk.Label(product_frame, text="Stock actual: ‚Äî", foreground="#6c757d")
        self.stock_label.grid(row=1, column=1, padx=5, pady=2, sticky="w")

        ttk.Button(product_frame, text="‚äï Agregar √çtem", command=self.add_item_to_pedido).grid(row=0, column=6, padx=10, pady=5)

        # --- √çtems actuales ---
        items_frame = ttk.LabelFrame(add_window, text="√çtems del Pedido", padding="10")
        items_frame.pack(fill="both", expand=True, padx=10, pady=5)

        items_columns = ("ID", "Nombre", "Cantidad", "Precio Unit.", "Subtotal")
        self.items_tree = ttk.Treeview(items_frame, columns=items_columns, show="headings")
        for col in items_columns:
            self.items_tree.heading(col, text=col)
            self.items_tree.column(col, width=100, anchor=tk.CENTER)
        self.items_tree.column("Nombre", width=180, anchor=tk.W)
        self.items_tree.pack(fill="both", expand=True)

        ttk.Button(items_frame, text="‚ûñ Quitar √çtem", command=self.remove_item_from_pedido).pack(pady=5)

        # --- Bot√≥n final ---
        ttk.Button(add_window, text="üíæ Registrar Pedido", command=self.final_register_pedido, style="T.Blue.TButton").pack(pady=10)

    def open_edit_pedido_window(self):
        if self.is_window_open(self.edit_pedido_window):
            self.edit_pedido_window.focus()
            return

        selected_item = self.pedidos_tree.focus()
        if not selected_item:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido para editar.")
            return

        pedido_id = self.pedidos_tree.item(selected_item, 'values')[0]
        try:
            pedido = obtener_pedido_por_id(pedido_id)
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo cargar el pedido:\n{e}")
            return

        if not pedido:
            messagebox.showerror("‚ùå Error", "Pedido no encontrado.")
            return

        edit_window = tk.Toplevel(self.root)
        self.edit_pedido_window = edit_window
        edit_window.title(f"‚úèÔ∏è Editar Pedido #{pedido_id}")
        edit_window.geometry("500x220")
        edit_window.transient(self.root)
        edit_window.grab_set()

        def on_close():
            self.edit_pedido_window = None
            edit_window.destroy()
        edit_window.protocol("WM_DELETE_WINDOW", on_close)

        frame = ttk.LabelFrame(edit_window, text="Editar Datos Generales", padding="10")
        frame.pack(padx=10, pady=10, fill="both", expand=True)

        # Proveedor
        ttk.Label(frame, text="Proveedor: *").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.edit_proveedor_var = tk.StringVar()
        combo = ttk.Combobox(frame, textvariable=self.edit_proveedor_var, values=list(self.proveedor_id_map.keys()), state="readonly", width=35)
        combo.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        # Set current
        current_prov_name = pedido.get('proveedor_nombre')
        if current_prov_name in self.proveedor_id_map:
            combo.set(current_prov_name)
        else:
            combo.set(list(self.proveedor_id_map.keys())[0] if self.proveedor_id_map else "")

        # Fecha
        ttk.Label(frame, text="Fecha Entrega Estimada (YYYY-MM-DD): *").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        current_fecha = str(pedido.get('fecha_entrega_estimada') or '')
        self.edit_fecha_entrega_var = tk.StringVar(value=current_fecha)
        fecha_entry = ttk.Entry(frame, textvariable=self.edit_fecha_entrega_var, width=30)
        fecha_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")

        # ‚ö†Ô∏è Mensaje explicativo
        ttk.Label(frame, text="‚ö†Ô∏è Nota: Solo se pueden editar datos generales.\nPara modificar productos, cancele este pedido y cree uno nuevo.",
                  foreground="#e74c3c", font=("Arial", 9)).grid(row=2, column=0, columnspan=2, pady=5)

        def save_changes():
            try:
                new_prov_name = self.edit_proveedor_var.get().strip()
                new_fecha = self.edit_fecha_entrega_var.get().strip()

                if not new_prov_name or not new_fecha:
                    messagebox.showerror("‚ùå Error", "Complete todos los campos obligatorios.", parent=edit_window)
                    return

                proveedor_id = self.proveedor_id_map.get(new_prov_name)
                if not proveedor_id:
                    messagebox.showerror("‚ùå Error", "Proveedor seleccionado inv√°lido.", parent=edit_window)
                    return

                fecha_valida = validar_fecha(new_fecha)
                if not fecha_valida:
                    messagebox.showerror("‚ùå Error", "Formato de fecha inv√°lido. Use YYYY-MM-DD.", parent=edit_window)
                    return

                exito, mensaje = update_pedido_details(pedido_id, proveedor_id, fecha_valida)
                if exito:
                    messagebox.showinfo("‚úÖ √âxito", mensaje, parent=edit_window)
                    self.load_pedidos()
                    edit_window.destroy()
                else:
                    messagebox.showerror("‚ùå Error", mensaje, parent=edit_window)

            except Exception as e:
                messagebox.showerror("‚ùå Error", f"Error al guardar:\n{e}", parent=edit_window)

        btn_frame = tk.Frame(frame)
        btn_frame.grid(row=3, column=0, columnspan=2, pady=15)
        ttk.Button(btn_frame, text="üíæ Guardar", command=save_changes, style="T.Blue.TButton").pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Cancelar", command=edit_window.destroy).pack(side="left", padx=5)

    # --- Funciones de √≠tems ---
    def add_item_to_pedido(self):
        try:
            prod_key = self.producto_var.get().strip()
            if not prod_key:
                messagebox.showerror("‚ùå Error", "Seleccione un producto.")
                return

            cantidad_str = self.cantidad_entry.get().strip()
            precio_str = self.precio_unitario_entry.get().strip()

            if not cantidad_str or not precio_str:
                messagebox.showerror("‚ùå Error", "Complete Cantidad y Precio.")
                return

            cantidad = int(cantidad_str)
            precio = float(precio_str.replace(',', '.'))

            if cantidad <= 0:
                messagebox.showerror("‚ùå Error", "La cantidad debe ser mayor a cero.")
                return
            if precio <= 0:
                messagebox.showerror("‚ùå Error", "El precio debe ser mayor a cero.")
                return

            producto = self.product_map.get(prod_key)
            if not producto:
                messagebox.showerror("‚ùå Error", "Producto seleccionado inv√°lido.")
                return

            subtotal = round(cantidad * precio, 2)
            item = {
                'producto_id': producto['id'],
                'producto_nombre': prod_key.split(' (')[0],
                'cantidad': cantidad,
                'precio_unitario': precio,
                'subtotal': subtotal
            }

            self.new_pedido_items.append(item)
            self.update_items_tree()

            # Limpiar campos, pero mantener producto seleccionado para seguir a√±adiendo
            self.cantidad_entry.delete(0, tk.END)
            self.cantidad_entry.insert(0, "1")
            self.precio_unitario_entry.focus()

        except ValueError:
            messagebox.showerror("‚ùå Error", "Cantidad y Precio deben ser n√∫meros v√°lidos.")

    def remove_item_from_pedido(self):
        selected = self.items_tree.focus()
        if not selected:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un √≠tem para eliminar.")
            return

        idx = self.items_tree.index(selected)
        if 0 <= idx < len(self.new_pedido_items):
            self.new_pedido_items.pop(idx)
            self.update_items_tree()

    def update_items_tree(self):
        for item in self.items_tree.get_children():
            self.items_tree.delete(item)
        for item in self.new_pedido_items:
            self.items_tree.insert("", tk.END, values=(
                item['producto_id'],
                item['producto_nombre'],
                item['cantidad'],
                f"${item['precio_unitario']:.2f}",
                f"${item['subtotal']:.2f}"
            ))

    # --- Registro final ---
    def final_register_pedido(self):
        if not self.new_pedido_items:
            messagebox.showerror("‚ùå Error", "Debe agregar al menos un producto al pedido.")
            return

        proveedor_name = self.proveedor_var.get().strip()
        if not proveedor_name:
            messagebox.showerror("‚ùå Error", "Seleccione un proveedor.")
            return

        fecha_estimada = self.fecha_estimada_entry.get().strip()
        fecha_valida = validar_fecha(fecha_estimada)
        if not fecha_valida:
            messagebox.showerror("‚ùå Error", "Fecha de entrega inv√°lida. Use formato YYYY-MM-DD.")
            return

        try:
            proveedor_id = self.proveedor_id_map[proveedor_name]
            items = [
                {
                    'producto_id': item['producto_id'],
                    'cantidad': item['cantidad'],
                    'precio_unitario': item['precio_unitario'],
                    'subtotal': item['subtotal']
                }
                for item in self.new_pedido_items
            ]

            exito, mensaje = registrar_pedido(proveedor_id, items, fecha_valida)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje)
                self.load_pedidos()
                self.add_pedido_window.destroy()
                self.add_pedido_window = None
            else:
                messagebox.showerror("‚ùå Error", mensaje)

        except KeyError:
            messagebox.showerror("‚ùå Error", "Proveedor seleccionado inv√°lido.")
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Error al registrar pedido:\n{e}")

    # --- Otras acciones ---
    def update_status(self, new_status):
        selected = self.pedidos_tree.focus()
        if not selected:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido.")
            return

        values = self.pedidos_tree.item(selected, 'values')
        pedido_id = values[0]
        estado_actual = values[4]

        if estado_actual == new_status:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", f"El pedido ya est√° en estado '{new_status}'.")
            return

        if new_status == 'Recibido':
            if not messagebox.askyesno("‚ùì Confirmar Recepci√≥n",
                f"¬øConfirma que ha recibido el Pedido #{pedido_id}?\n"
                "‚ö†Ô∏è Esto aumentar√° el stock de los productos incluidos.",
                parent=self.root):
                return

        try:
            exito, mensaje = actualizar_estado_pedido(pedido_id, new_status)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje)
                self.load_pedidos()
            else:
                messagebox.showerror("‚ùå Error", mensaje)
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Error al actualizar estado:\n{e}")

    def delete_pedido_action(self):
        selected = self.pedidos_tree.focus()
        if not selected:
            messagebox.showwarning("‚ö†Ô∏è Advertencia", "Seleccione un pedido.")
            return

        values = self.pedidos_tree.item(selected, 'values')
        pedido_id, proveedor = values[0], values[1]

        if not messagebox.askyesno("‚ùì Confirmar Eliminaci√≥n",
            f"¬øEliminar el Pedido #{pedido_id} al proveedor {proveedor}?\n"
            "‚ö†Ô∏è Esta acci√≥n es irreversible.",
            parent=self.root):
            return

        try:
            exito, mensaje = eliminar_pedido(pedido_id)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje)
                self.load_pedidos()
            else:
                messagebox.showerror("‚ùå Error", mensaje)
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Error al eliminar:\n{e}")

    def back_to_dashboard(self):
        self.root.destroy()
        try:
            from dashboard_view import DashboardView
            root = tk.Tk()
            DashboardView(root, self.usuario)
            root.mainloop()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo abrir el dashboard:\n{e}")


            # products_controller.py
from database import conectar
import logging

# Configura logging (en producci√≥n, usa un archivo)
logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)


def get_all_products():
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            logger.error("No se pudo conectar a la base de datos en get_all_products")
            return []

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT 
                p.id,
                p.nombre,
                p.descripcion,
                p.precio_compra,
                p.precio_venta,
                p.stock,
                p.categoria,
                p.proveedor_id,
                p.fecha_ingreso,
                pr.nombre_empresa AS proveedor_nombre
            FROM productos p
            INNER JOIN proveedores pr ON p.proveedor_id = pr.id
            WHERE p.activo = 1
            ORDER BY p.nombre ASC
        """
        cursor.execute(query)
        productos = cursor.fetchall()
        return productos

    except Exception as e:
        logger.exception("Error al obtener productos")
        return []
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


def add_product(nombre, descripcion, precio_compra, precio_venta, stock, categoria, proveedor_id, fecha_ingreso):
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return False, "No se pudo conectar a la base de datos."

        cursor = conn.cursor()
        query = """
            INSERT INTO productos (
                nombre, descripcion, precio_compra, precio_venta, 
                stock, categoria, proveedor_id, fecha_ingreso
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        cursor.execute(query, (
            nombre, descripcion, precio_compra, precio_venta,
            stock, categoria, proveedor_id, fecha_ingreso
        ))
        conn.commit()
        return True, "Producto agregado exitosamente."

    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error al agregar producto")
        return False, "Error al agregar el producto. Intente nuevamente."
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


def update_product(producto_id, nombre, descripcion, precio_compra, precio_venta, stock, categoria, proveedor_id):
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return False, "No se pudo conectar a la base de datos."

        cursor = conn.cursor()
        # üîí Solo actualiza si el producto existe Y est√° activo (evita reactivar por error)
        query = """
            UPDATE productos 
            SET 
                nombre = %s, 
                descripcion = %s, 
                precio_compra = %s, 
                precio_venta = %s, 
                stock = %s, 
                categoria = %s, 
                proveedor_id = %s,
                fecha_actualizacion = CURRENT_TIMESTAMP
            WHERE id = %s AND activo = 1
        """
        cursor.execute(query, (
            nombre, descripcion, precio_compra, precio_venta,
            stock, categoria, proveedor_id, producto_id
        ))
        
        if cursor.rowcount == 0:
            return False, "Producto no encontrado o ya eliminado."
        
        conn.commit()
        return True, "Producto actualizado exitosamente."

    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error al actualizar producto")
        return False, "Error al actualizar el producto. Intente nuevamente."
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


def delete_product(producto_id):
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return False, "No se pudo conectar a la base de datos."

        cursor = conn.cursor()
        # üõë Solo desactiva si est√° activo (evita doble eliminaci√≥n)
        query = "UPDATE productos SET activo = 0 WHERE id = %s AND activo = 1"
        cursor.execute(query, (producto_id,))
        
        if cursor.rowcount == 0:
            return False, "Producto no encontrado o ya eliminado."
        
        conn.commit()
        return True, "Producto eliminado correctamente."

    except Exception as e:
        if conn:
            conn.rollback()
        logger.exception("Error al eliminar producto")
        return False, "Error al eliminar el producto. Intente nuevamente."
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


            # products_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from products_controller import get_all_products, add_product, update_product, delete_product
from suppliers_controller import obtener_todos_proveedores
from datetime import datetime


def validate_date(date_str):
    try:
        datetime.strptime(date_str, "%Y-%m-%d")
        return True
    except ValueError:
        return False


class ProductsView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üì¶ Gesti√≥n de Productos - Papeler√≠a √Ångel")
        self.root.geometry("1250x700")
        self.root.configure(bg="#f5f7fa")

        # Barra superior
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üì¶ Gesti√≥n de Productos", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(
            side="left", padx=20, pady=10
        )
        tk.Button(
            top_bar,
            text="üö™ Cerrar Sesi√≥n",
            command=self.confirmar_cierre,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief="flat",
            padx=10,
        ).pack(side="right", padx=20, pady=10)

        # Bot√≥n volver
        back_btn = tk.Button(
            root,
            text="‚Üê Volver al Dashboard",
            command=self.back_to_dashboard,
            bg="#6c757d",
            fg="white",
            font=("Arial", 10),
        )
        back_btn.pack(anchor="nw", padx=20, pady=10)

        # Frame principal
        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)
        main_frame.grid_rowconfigure(1, weight=1)
        main_frame.grid_columnconfigure(0, weight=1)

        # Formulario
        self.create_form(main_frame)

        # Tabla
        self.create_table(main_frame)

        self.load_products()

    def create_form(self, parent):
        form_frame = tk.LabelFrame(
            parent,
            text="Agregar Nuevo Producto",
            font=("Arial", 12, "bold"),
            bg="#f5f7fa",
            padx=15,
            pady=15,
        )
        form_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)

        # Entradas
        labels = [
            "Nombre:",
            "Descripci√≥n:",
            "Precio Compra:",
            "Precio Venta:",
            "Stock:",
            "Categor√≠a:",
            "Proveedor:",
            "Fecha Ingreso:",
        ]
        self.entries = {}
        for i, text in enumerate(labels):
            tk.Label(form_frame, text=text, bg="#f5f7fa", font=("Arial", 11)).grid(
                row=i, column=0, sticky="w", pady=5
            )

        # Campos espec√≠ficos
        self.name_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.name_entry.grid(row=0, column=1, padx=10, pady=5)

        self.desc_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.desc_entry.grid(row=1, column=1, padx=10, pady=5)

        self.buy_price_entry = tk.Entry(form_frame, font=("Arial", 12), width=15, relief="solid", bd=1)
        self.buy_price_entry.grid(row=2, column=1, padx=10, pady=5)

        self.sell_price_entry = tk.Entry(form_frame, font=("Arial", 12), width=15, relief="solid", bd=1)
        self.sell_price_entry.grid(row=3, column=1, padx=10, pady=5)

        self.stock_entry = tk.Entry(form_frame, font=("Arial", 12), width=15, relief="solid", bd=1)
        self.stock_entry.grid(row=4, column=1, padx=10, pady=5)

        self.category_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.category_entry.grid(row=5, column=1, padx=10, pady=5)

        # Proveedor (Combobox)
        try:
            proveedores = obtener_todos_proveedores()
            if proveedores is None:
                proveedores = []
            self.lista_proveedores = [f"{p['id']} - {p['nombre_empresa']}" for p in proveedores]
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los proveedores:\n{e}", parent=self.root)
            self.lista_proveedores = []

        self.proveedor_var = tk.StringVar()
        self.proveedor_combo = ttk.Combobox(
            form_frame,
            textvariable=self.proveedor_var,
            values=self.lista_proveedores,
            state="readonly",
            width=28,
        )
        self.proveedor_combo.grid(row=6, column=1, padx=10, pady=5)
        if self.lista_proveedores:
            self.proveedor_combo.set(self.lista_proveedores[0])
        else:
            self.proveedor_combo.set("")

        # Fecha
        self.date_entry = tk.Entry(form_frame, font=("Arial", 12), width=15, relief="solid", bd=1)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.date_entry.grid(row=7, column=1, padx=10, pady=5)

        # Bot√≥n
        add_btn = tk.Button(
            form_frame,
            text="‚ûï Agregar Producto",
            command=self.add_product,
            bg="#2ecc71",
            fg="white",
            font=("Arial", 12, "bold"),
        )
        add_btn.grid(row=8, column=0, columnspan=2, pady=15)

    def create_table(self, parent):
        table_frame = tk.LabelFrame(
            parent,
            text="Lista de Productos",
            font=("Arial", 12, "bold"),
            bg="#f5f7fa",
            padx=15,
            pady=15,
        )
        table_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

        columns = ("ID", "Nombre", "Descripci√≥n", "Compra", "Venta", "Stock", "Categor√≠a", "Proveedor", "Fecha", "Editar", "Eliminar")
        self.tree = ttk.Treeview(table_frame, columns=columns, show="headings", height=15)

        col_widths = {
            "ID": 60,
            "Nombre": 150,
            "Descripci√≥n": 200,
            "Compra": 80,
            "Venta": 80,
            "Stock": 60,
            "Categor√≠a": 100,
            "Proveedor": 120,
            "Fecha": 100,
            "Editar": 60,
            "Eliminar": 60,
        }

        for col in columns:
            self.tree.heading(col, text=col)
            width = col_widths.get(col, 100)
            anchor = "center" if col in ("Editar", "Eliminar", "ID", "Stock") else "w"
            self.tree.column(col, width=width, anchor=anchor)

        self.tree.pack(fill="both", expand=True)

        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")

        self.tree.bind("<ButtonRelease-1>", self.on_tree_click)

        btn_frame = tk.Frame(table_frame, bg="#f5f7fa")
        btn_frame.pack(pady=10)
        tk.Button(
            btn_frame,
            text="üîÑ Actualizar",
            command=self.load_products,
            bg="#3498db",
            fg="white",
            font=("Arial", 11),
        ).pack()

    def extract_proveedor_id(self, proveedor_str):
        """Extrae el ID del proveedor desde el string 'ID - Nombre'."""
        if not proveedor_str.strip():
            return None
        try:
            return int(proveedor_str.split(" - ")[0])
        except (ValueError, IndexError):
            return None

    def validate_inputs(self, nombre, precio_compra, precio_venta, stock, proveedor_str, categoria, fecha="", is_edit=False):
        # Campos obligatorios
        required = [nombre, precio_compra, precio_venta, stock, proveedor_str, categoria]
        if not all(required):
            return False, "Los campos Nombre, Precio Compra, Precio Venta, Stock, Categor√≠a y Proveedor son obligatorios."

        # Conversi√≥n num√©rica
        try:
            precio_compra = float(precio_compra)
            precio_venta = float(precio_venta)
            stock = int(stock)
        except ValueError:
            return False, "Precio Compra, Precio Venta y Stock deben ser n√∫meros v√°lidos."

        # Proveedor ID
        proveedor_id = self.extract_proveedor_id(proveedor_str)
        if proveedor_id is None:
            return False, "Proveedor inv√°lido. Seleccione uno de la lista."

        # Fecha (solo en alta)
        if not is_edit:
            if not validate_date(fecha):
                return False, "La fecha debe tener formato YYYY-MM-DD."

        return True, (nombre, precio_compra, precio_venta, stock, categoria, proveedor_id, fecha if not is_edit else None)

    def add_product(self):
        nombre = self.name_entry.get().strip()
        descripcion = self.desc_entry.get().strip()
        precio_compra = self.buy_price_entry.get().strip()
        precio_venta = self.sell_price_entry.get().strip()
        stock = self.stock_entry.get().strip()
        categoria = self.category_entry.get().strip()
        proveedor_str = self.proveedor_var.get().strip()
        fecha = self.date_entry.get().strip()

        valid, result = self.validate_inputs(nombre, precio_compra, precio_venta, stock, proveedor_str, categoria, fecha)
        if not valid:
            messagebox.showwarning("‚ö†Ô∏è Validaci√≥n", result)
            return

        success, msg = add_product(*result[:-1], descripcion, result[-1])  # (*args: nombre, pc, pv, stock, cat, prov_id), descr, fecha
        if success:
            messagebox.showinfo("‚úÖ √âxito", msg)
            self.clear_form()
            self.load_products()
        else:
            messagebox.showerror("‚ùå Error", msg)

    def clear_form(self):
        self.name_entry.delete(0, tk.END)
        self.desc_entry.delete(0, tk.END)
        self.buy_price_entry.delete(0, tk.END)
        self.sell_price_entry.delete(0, tk.END)
        self.stock_entry.delete(0, tk.END)
        self.category_entry.delete(0, tk.END)
        if self.lista_proveedores:
            self.proveedor_combo.set(self.lista_proveedores[0])
        else:
            self.proveedor_var.set("")
        self.date_entry.delete(0, tk.END)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))

    def load_products(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
        try:
            productos = get_all_products()
            if productos is None:
                productos = []
            for p in productos:
                self.tree.insert(
                    "",
                    "end",
                    values=(
                        p["id"],
                        p["nombre"],
                        p["descripcion"],
                        f"${p['precio_compra']:.2f}",
                        f"${p['precio_venta']:.2f}",
                        p["stock"],
                        p["categoria"],
                        p.get("proveedor_nombre", "‚Äî"),
                        p["fecha_ingreso"],
                        "‚úèÔ∏è",
                        "üóëÔ∏è",
                    ),
                )
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los productos:\n{e}")

    def on_tree_click(self, event):
        region = self.tree.identify("region", event.x, event.y)
        if region != "cell":
            return
        column = self.tree.identify_column(event.x)
        item = self.tree.identify_row(event.y)
        if not item:
            return
        values = self.tree.item(item, "values")
        if not values:
            return
        producto_id = values[0]
        if column == "#10":  # Editar
            self.edit_selected_direct(producto_id)
        elif column == "#11":  # Eliminar
            self.delete_selected_direct(producto_id)

    def edit_selected_direct(self, producto_id):
        try:
            productos = get_all_products()
            producto = next((p for p in productos if str(p["id"]) == str(producto_id)), None)
        except Exception:
            producto = None

        if not producto:
            messagebox.showerror("‚ùå Error", "Producto no encontrado.")
            return

        edit_window = tk.Toplevel(self.root)
        edit_window.title(f"Editar Producto ID: {producto_id}")
        edit_window.geometry("450x500")
        edit_window.configure(bg="#f5f7fa")
        edit_window.transient(self.root)
        edit_window.grab_set()

        tk.Label(edit_window, text=f"Editar Producto: {producto['nombre']}", font=("Arial", 14, "bold"), bg="#f5f7fa").pack(pady=10)

        form = tk.Frame(edit_window, bg="#f5f7fa")
        form.pack(padx=20, pady=10, fill="x")

        fields = [
            ("Nombre:", producto["nombre"]),
            ("Descripci√≥n:", producto["descripcion"]),
            ("Precio Compra:", producto["precio_compra"]),
            ("Precio Venta:", producto["precio_venta"]),
            ("Stock:", producto["stock"]),
            ("Categor√≠a:", producto["categoria"]),
        ]

        entries = {}
        for i, (label, value) in enumerate(fields):
            tk.Label(form, text=label, bg="#f5f7fa", font=("Arial", 11)).grid(row=i, column=0, sticky="w", pady=5)
            entry = tk.Entry(form, font=("Arial", 12), width=30, relief="solid", bd=1)
            entry.insert(0, str(value))
            entry.grid(row=i, column=1, padx=10, pady=5)
            entries[label] = entry

        # Proveedor
        tk.Label(form, text="Proveedor:", bg="#f5f7fa", font=("Arial", 11)).grid(row=6, column=0, sticky="w", pady=5)
        try:
            proveedores = obtener_todos_proveedores() or []
            lista = [f"{p['id']} - {p['nombre_empresa']}" for p in proveedores]
        except Exception:
            lista = []
        proveedor_var = tk.StringVar()
        combo = ttk.Combobox(form, textvariable=proveedor_var, values=lista, state="readonly", width=28)
        combo.grid(row=6, column=1, padx=10, pady=5)
        # Set current
        current = f"{producto['proveedor_id']} - {producto.get('proveedor_nombre', 'Desconocido')}"
        if current in lista:
            combo.set(current)
        elif lista:
            combo.set(lista[0])

        def save_changes():
            nombre = entries["Nombre:"].get().strip()
            descripcion = entries["Descripci√≥n:"].get().strip()
            precio_compra = entries["Precio Compra:"].get().strip()
            precio_venta = entries["Precio Venta:"].get().strip()
            stock = entries["Stock:"].get().strip()
            categoria = entries["Categor√≠a:"].get().strip()
            proveedor_str = proveedor_var.get()

            valid, result = self.validate_inputs(
                nombre, precio_compra, precio_venta, stock, proveedor_str, categoria, is_edit=True
            )
            if not valid:
                messagebox.showwarning("‚ö†Ô∏è Validaci√≥n", result, parent=edit_window)
                return

            success, msg = update_product(producto_id, *result[:5], descripcion, result[5])  # id, nombre, pc, pv, stock, cat, descr, prov_id
            if success:
                messagebox.showinfo("‚úÖ √âxito", "Producto actualizado correctamente.", parent=edit_window)
                edit_window.destroy()
                self.load_products()
            else:
                messagebox.showerror("‚ùå Error", msg, parent=edit_window)

        btn_frame = tk.Frame(edit_window, bg="#f5f7fa")
        btn_frame.pack(pady=20)
        tk.Button(
            btn_frame,
            text="üíæ Guardar",
            command=save_changes,
            bg="#2ecc71",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
        ).pack(side="left", padx=5)
        tk.Button(
            btn_frame,
            text="‚ùå Cancelar",
            command=edit_window.destroy,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 11, "bold"),
            width=10,
        ).pack(side="left", padx=5)

    def delete_selected_direct(self, producto_id):
        if messagebox.askyesno(
            "‚ùì Confirmar eliminaci√≥n",
            f"¬øEst√° seguro de eliminar el producto ID {producto_id}?\n‚ö†Ô∏è Esta acci√≥n lo ocultar√° del inventario.",
            parent=self.root,
        ):
            success, msg = delete_product(producto_id)
            if success:
                messagebox.showinfo("‚úÖ √âxito", "Producto eliminado correctamente.", parent=self.root)
                self.load_products()
            else:
                messagebox.showerror("‚ùå Error", msg, parent=self.root)

    # üî¥ Importante: No crear Tk() dentro de Tk()
    def back_to_dashboard(self):
        from dashboard_view import DashboardView
        self.root.destroy()
        # Ideal: que el main.py o app.py gestione esto.
        # Por ahora, asumimos que el dashboard espera un root nuevo.
        root = tk.Tk()
        DashboardView(root, self.usuario)
        root.mainloop()

    def confirmar_cierre(self):
        if messagebox.askyesno(
            "‚ùì Cerrar sesi√≥n",
            f"¬øEst√° seguro que desea cerrar sesi√≥n como {self.usuario.get('nombre', 'Usuario')}?",
        ):
            from login import LoginView
            self.root.destroy()
            root = tk.Tk()
            LoginView(root)
            root.mainloop()
        else:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", "Se ha cancelado el cierre de sesi√≥n.")



            #sales_contoller.py
import tkinter as tk
from tkinter import ttk, messagebox
from sales_controller import registrar_venta
from database import conectar
from datetime import datetime
import logging
import sys
import os


class VentasView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üí∞ Registrar Venta - Papeler√≠a √Ångel")
        self.root.geometry("650x550")
        self.root.configure(bg="#f5f7fa")
        self.root.resizable(False, False)
        self.root.protocol("WM_DELETE_WINDOW", self.volver_dashboard)

        # Estado
        self.producto_id_map = {}  # {"Display Text": product_id}
        self.registrando = False

        # --- Barra superior ---
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üí∞ Registrar Nueva Venta", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(
            top_bar,
            text="üö™ Cerrar Sesi√≥n",
            command=self.confirmar_cierre,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief="flat",
            padx=10
        ).pack(side="right", padx=20, pady=10)

        back_btn = tk.Button(root, text="‚Üê Volver al Dashboard", command=self.volver_dashboard, bg="#6c757d", fg="white", font=("Arial", 10))
        back_btn.pack(anchor="nw", padx=20, pady=10)

        # --- Formulario ---
        form_frame = tk.Frame(root, bg="#f5f7fa", padx=30, pady=20)
        form_frame.pack(fill="both", expand=True)

        tk.Label(form_frame, text="Selecciona un producto:", bg="#f5f7fa", font=("Arial", 12, "bold")).pack(anchor="w", pady=(0, 5))

        self.cargar_productos()
        if not self.producto_id_map:
            messagebox.showwarning("‚ö†Ô∏è Sin productos", "No hay productos disponibles para vender.", parent=root)
            self.root.after(500, self.volver_dashboard)
            return

        # ‚úÖ ID-based mapping (no more .index()!)
        self.producto_var = tk.StringVar()
        self.producto_combo = ttk.Combobox(
            form_frame,
            textvariable=self.producto_var,
            values=list(self.producto_id_map.keys()),
            state="readonly",
            width=45,
            font=("Arial", 11)
        )
        self.producto_combo.pack(pady=5)
        self.producto_combo.current(0)
        self.producto_combo.bind("<<ComboboxSelected>>", self.actualizar_datos_producto)

        # Precio y cantidad
        tk.Label(form_frame, text="Precio unitario:", bg="#f5f7fa", font=("Arial", 12)).pack(anchor="w", pady=(15, 5))
        self.precio_label = tk.Label(form_frame, text="$0.00", bg="#f5f7fa", font=("Arial", 12, "bold"), fg="#27ae60")
        self.precio_label.pack(anchor="w")

        tk.Label(form_frame, text="Cantidad (m√°x. stock disponible):", bg="#f5f7fa", font=("Arial", 12, "bold")).pack(anchor="w", pady=(15, 5))
        self.cantidad_entry = tk.Entry(form_frame, font=("Arial", 12), width=10, relief="solid", bd=1)
        self.cantidad_entry.pack(anchor="w", pady=5)
        self.cantidad_entry.insert(0, "1")
        self.cantidad_entry.bind("<KeyRelease>", self.actualizar_total)
        
        # Stock actual (din√°mico)
        self.stock_label = tk.Label(form_frame, text="üì¶ Stock: ‚Äî", bg="#f5f7fa", font=("Arial", 10), fg="#8e44ad")
        self.stock_label.pack(anchor="w", pady=(2, 5))

        tk.Label(form_frame, text="Total:", bg="#f5f7fa", font=("Arial", 12, "bold")).pack(anchor="w", pady=(10, 5))
        self.total_label = tk.Label(form_frame, text="$0.00", bg="#f5f7fa", font=("Arial", 14, "bold"), fg="#27ae60")
        self.total_label.pack(anchor="w")

        # Botones
        btn_frame = tk.Frame(form_frame, bg="#f5f7fa")
        btn_frame.pack(pady=25)
        
        self.registrar_btn = tk.Button(
            btn_frame,
            text="‚úÖ Registrar Venta",
            command=self.registrar_venta,
            bg="#2ecc71",
            fg="white",
            font=("Arial", 12, "bold"),
            width=18
        )
        self.registrar_btn.pack(side="left", padx=5)
        
        tk.Button(
            btn_frame,
            text="‚ùå Cancelar",
            command=self.volver_dashboard,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 12, "bold"),
            width=12
        ).pack(side="left", padx=5)

        # Inicializar
        self.actualizar_datos_producto(None)

    def cargar_productos(self):
        """Carga productos y crea mapeo ID seguro."""
        try:
            productos = self.obtener_productos_actualizados()
            self.producto_id_map = {}
            for p in productos:
                # ‚úÖ Seguro contra cambios en formato
                display = f"{p['nombre']} (ID: {p['id']}) - ${p['precio_venta']:.2f} | Stock: {p['stock']}"
                self.producto_id_map[display] = {
                    'id': p['id'],
                    'nombre': p['nombre'],
                    'precio': float(p['precio_venta']),
                    'stock': int(p['stock'])
                }
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los productos:\n{e}")

    def obtener_productos_actualizados(self):
        """Hook para sobrescribir en testing."""
        from sales_controller import obtener_productos_activos
        productos = obtener_productos_activos()
        # Asegurar tipos num√©ricos
        for p in productos:
            p['precio_venta'] = float(p.get('precio_venta', 0))
            p['stock'] = int(p.get('stock', 0))
        return productos

    def actualizar_datos_producto(self, event):
        """Actualiza precio, stock y total al cambiar producto."""
        display = self.producto_var.get()
        producto = self.producto_id_map.get(display)
        if producto:
            self.precio_label.config(text=f"${producto['precio']:.2f}")
            self.stock_label.config(text=f"üì¶ Stock actual: {producto['stock']} unidades")
            self.actualizar_total(None)

    def actualizar_total(self, event):
        """Calcula total y valida cantidad."""
        try:
            cantidad = int(self.cantidad_entry.get() or 1)
        except ValueError:
            cantidad = 1

        display = self.producto_var.get()
        producto = self.producto_id_map.get(display)
        if producto:
            # Asegurar cantidad v√°lida
            if cantidad < 1:
                cantidad = 1
            elif cantidad > producto['stock']:
                messagebox.showinfo(
                    "‚ÑπÔ∏è Stock m√°ximo",
                    f"Solo hay {producto['stock']} unidades disponibles.\nAjustando cantidad.",
                    parent=self.root
                )
                cantidad = producto['stock']

            self.cantidad_entry.delete(0, tk.END)
            self.cantidad_entry.insert(0, str(cantidad))

            total = producto['precio'] * cantidad
            self.total_label.config(text=f"${total:.2f}")

    def registrar_venta(self):
        if self.registrando:
            return  # Evita doble clic

        display = self.producto_var.get()
        producto = self.producto_id_map.get(display)
        if not producto:
            messagebox.showwarning("‚ö†Ô∏è Selecci√≥n inv√°lida", "Seleccione un producto de la lista.", parent=self.root)
            return

        try:
            cantidad = int(self.cantidad_entry.get())
            if cantidad <= 0 or cantidad > producto['stock']:
                messagebox.showerror("‚ùå Cantidad inv√°lida", f"Ingrese una cantidad entre 1 y {producto['stock']}.", parent=self.root)
                return

            # üîí Bloquear UI
            self.registrando = True
            self.registrar_btn.config(state="disabled", text="‚è≥ Procesando...")
            self.root.update_idletasks()

            # ‚úÖ Llamada AT√ìMICA (venta + stock en una transacci√≥n)
            exito, mensaje = registrar_venta(
                producto_id=producto['id'],
                usuario_id=self.usuario['id'],
                cantidad=cantidad,
                precio_unitario=producto['precio']
            )

            if exito:
                messagebox.showinfo(
                    "‚úÖ ¬°Venta Exitosa!",
                    f"Producto: {producto['nombre']}\nCantidad: {cantidad}\nTotal: ${producto['precio'] * cantidad:.2f}",
                    parent=self.root
                )
                self.root.after(300, self.volver_dashboard)
            else:
                messagebox.showerror("‚ùå Error", mensaje, parent=self.root)
                self.registrando = False
                self.registrar_btn.config(state="normal", text="‚úÖ Registrar Venta")

        except Exception as e:
            messagebox.showerror("‚ùå Error inesperado", f"No se pudo registrar la venta:\n{e}", parent=self.root)
            self.registrando = False
            self.registrar_btn.config(state="normal", text="‚úÖ Registrar Venta")

    def volver_dashboard(self):
        self.root.destroy()
        try:
            from dashboard_view import DashboardView
            root = tk.Tk()
            DashboardView(root, self.usuario)
            root.mainloop()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo abrir el dashboard:\n{e}")

    def confirmar_cierre(self):
        if messagebox.askyesno("‚ùì Cerrar sesi√≥n", f"¬øCerrar sesi√≥n como {self.usuario.get('nombre', 'Usuario')}?"):
            self.root.destroy()
            try:
                from login import LoginView
                root = tk.Tk()
                LoginView(root)
                root.mainloop()
            except Exception as e:
                messagebox.showerror("‚ùå Error", f"No se pudo abrir el login:\n{e}")


                #sales_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from sales_controller import registrar_venta
import sys
import os


class VentasView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üí∞ Registrar Venta - Papeler√≠a √Ångel")
        self.root.geometry("650x550")
        self.root.configure(bg="#f5f7fa")
        self.root.resizable(False, False)
        self.root.protocol("WM_DELETE_WINDOW", self.volver_dashboard)

        # Estado
        self.producto_id_map = {}  # {"Display Text": product_id}
        self.registrando = False

        # --- Barra superior ---
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üí∞ Registrar Nueva Venta", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(
            top_bar,
            text="üö™ Cerrar Sesi√≥n",
            command=self.confirmar_cierre,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief="flat",
            padx=10
        ).pack(side="right", padx=20, pady=10)

        back_btn = tk.Button(root, text="‚Üê Volver al Dashboard", command=self.volver_dashboard, bg="#6c757d", fg="white", font=("Arial", 10))
        back_btn.pack(anchor="nw", padx=20, pady=10)

        # --- Formulario ---
        form_frame = tk.Frame(root, bg="#f5f7fa", padx=30, pady=20)
        form_frame.pack(fill="both", expand=True)

        tk.Label(form_frame, text="Selecciona un producto:", bg="#f5f7fa", font=("Arial", 12, "bold")).pack(anchor="w", pady=(0, 5))

        self.cargar_productos()
        if not self.producto_id_map:
            messagebox.showwarning("‚ö†Ô∏è Sin productos", "No hay productos disponibles para vender.", parent=root)
            self.root.after(500, self.volver_dashboard)
            return

        # ‚úÖ ID-based mapping (no more .index()!)
        self.producto_var = tk.StringVar()
        self.producto_combo = ttk.Combobox(
            form_frame,
            textvariable=self.producto_var,
            values=list(self.producto_id_map.keys()),
            state="readonly",
            width=45,
            font=("Arial", 11)
        )
        self.producto_combo.pack(pady=5)
        self.producto_combo.current(0)
        self.producto_combo.bind("<<ComboboxSelected>>", self.actualizar_datos_producto)

        # Precio y cantidad
        tk.Label(form_frame, text="Precio unitario:", bg="#f5f7fa", font=("Arial", 12)).pack(anchor="w", pady=(15, 5))
        self.precio_label = tk.Label(form_frame, text="$0.00", bg="#f5f7fa", font=("Arial", 12, "bold"), fg="#27ae60")
        self.precio_label.pack(anchor="w")

        tk.Label(form_frame, text="Cantidad (m√°x. stock disponible):", bg="#f5f7fa", font=("Arial", 12, "bold")).pack(anchor="w", pady=(15, 5))
        self.cantidad_entry = tk.Entry(form_frame, font=("Arial", 12), width=10, relief="solid", bd=1)
        self.cantidad_entry.pack(anchor="w", pady=5)
        self.cantidad_entry.insert(0, "1")
        self.cantidad_entry.bind("<KeyRelease>", self.actualizar_total)
        
        # Stock actual (din√°mico)
        self.stock_label = tk.Label(form_frame, text="üì¶ Stock: ‚Äî", bg="#f5f7fa", font=("Arial", 10), fg="#8e44ad")
        self.stock_label.pack(anchor="w", pady=(2, 5))

        tk.Label(form_frame, text="Total:", bg="#f5f7fa", font=("Arial", 12, "bold")).pack(anchor="w", pady=(10, 5))
        self.total_label = tk.Label(form_frame, text="$0.00", bg="#f5f7fa", font=("Arial", 14, "bold"), fg="#27ae60")
        self.total_label.pack(anchor="w")

        # Botones
        btn_frame = tk.Frame(form_frame, bg="#f5f7fa")
        btn_frame.pack(pady=25)
        
        self.registrar_btn = tk.Button(
            btn_frame,
            text="‚úÖ Registrar Venta",
            command=self.registrar_venta,
            bg="#2ecc71",
            fg="white",
            font=("Arial", 12, "bold"),
            width=18
        )
        self.registrar_btn.pack(side="left", padx=5)
        
        tk.Button(
            btn_frame,
            text="‚ùå Cancelar",
            command=self.volver_dashboard,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 12, "bold"),
            width=12
        ).pack(side="left", padx=5)

        # Inicializar
        self.actualizar_datos_producto(None)

    def cargar_productos(self):
        """Carga productos y crea mapeo ID seguro."""
        try:
            productos = self.obtener_productos_actualizados()
            self.producto_id_map = {}
            for p in productos:
                # ‚úÖ Seguro contra cambios en formato
                display = f"{p['nombre']} (ID: {p['id']}) - ${p['precio_venta']:.2f} | Stock: {p['stock']}"
                self.producto_id_map[display] = {
                    'id': p['id'],
                    'nombre': p['nombre'],
                    'precio': float(p['precio_venta']),
                    'stock': int(p['stock'])
                }
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudieron cargar los productos:\n{e}")

    def obtener_productos_actualizados(self):
        """Hook para sobrescribir en testing."""
        from sales_controller import obtener_productos_activos
        productos = obtener_productos_activos()
        # Asegurar tipos num√©ricos
        for p in productos:
            p['precio_venta'] = float(p.get('precio_venta', 0))
            p['stock'] = int(p.get('stock', 0))
        return productos

    def actualizar_datos_producto(self, event):
        """Actualiza precio, stock y total al cambiar producto."""
        display = self.producto_var.get()
        producto = self.producto_id_map.get(display)
        if producto:
            self.precio_label.config(text=f"${producto['precio']:.2f}")
            self.stock_label.config(text=f"üì¶ Stock actual: {producto['stock']} unidades")
            self.actualizar_total(None)

    def actualizar_total(self, event):
        """Calcula total y valida cantidad."""
        try:
            cantidad = int(self.cantidad_entry.get() or 1)
        except ValueError:
            cantidad = 1

        display = self.producto_var.get()
        producto = self.producto_id_map.get(display)
        if producto:
            # Asegurar cantidad v√°lida
            if cantidad < 1:
                cantidad = 1
            elif cantidad > producto['stock']:
                messagebox.showinfo(
                    "‚ÑπÔ∏è Stock m√°ximo",
                    f"Solo hay {producto['stock']} unidades disponibles.\nAjustando cantidad.",
                    parent=self.root
                )
                cantidad = producto['stock']

            self.cantidad_entry.delete(0, tk.END)
            self.cantidad_entry.insert(0, str(cantidad))

            total = producto['precio'] * cantidad
            self.total_label.config(text=f"${total:.2f}")

    def registrar_venta(self):
        if self.registrando:
            return  # Evita doble clic

        display = self.producto_var.get()
        producto = self.producto_id_map.get(display)
        if not producto:
            messagebox.showwarning("‚ö†Ô∏è Selecci√≥n inv√°lida", "Seleccione un producto de la lista.", parent=self.root)
            return

        try:
            cantidad = int(self.cantidad_entry.get())
            if cantidad <= 0 or cantidad > producto['stock']:
                messagebox.showerror("‚ùå Cantidad inv√°lida", f"Ingrese una cantidad entre 1 y {producto['stock']}.", parent=self.root)
                return

            # üîí Bloquear UI
            self.registrando = True
            self.registrar_btn.config(state="disabled", text="‚è≥ Procesando...")
            self.root.update_idletasks()

            # ‚úÖ Llamada AT√ìMICA (venta + stock en una transacci√≥n)
            exito, mensaje = registrar_venta(
                producto_id=producto['id'],
                usuario_id=self.usuario['id'],
                cantidad=cantidad,
                precio_unitario=producto['precio']
            )

            if exito:
                messagebox.showinfo(
                    "‚úÖ ¬°Venta Exitosa!",
                    f"Producto: {producto['nombre']}\nCantidad: {cantidad}\nTotal: ${producto['precio'] * cantidad:.2f}",
                    parent=self.root
                )
                self.root.after(300, self.volver_dashboard)
            else:
                messagebox.showerror("‚ùå Error", mensaje, parent=self.root)
                self.registrando = False
                self.registrar_btn.config(state="normal", text="‚úÖ Registrar Venta")

        except Exception as e:
            messagebox.showerror("‚ùå Error inesperado", f"No se pudo registrar la venta:\n{e}", parent=self.root)
            self.registrando = False
            self.registrar_btn.config(state="normal", text="‚úÖ Registrar Venta")

    def volver_dashboard(self):
        self.root.destroy()
        try:
            from dashboard_view import DashboardView
            root = tk.Tk()
            DashboardView(root, self.usuario)
            root.mainloop()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo abrir el dashboard:\n{e}")

    def confirmar_cierre(self):
        if messagebox.askyesno("‚ùì Cerrar sesi√≥n", f"¬øCerrar sesi√≥n como {self.usuario.get('nombre', 'Usuario')}?"):
            self.root.destroy()
            try:
                from login import LoginView
                root = tk.Tk()
                LoginView(root)
                root.mainloop()
            except Exception as e:
                messagebox.showerror("‚ùå Error", f"No se pudo abrir el login:\n{e}")


                # sales_history_controller.py
from database import conectar
from datetime import datetime, timedelta
import logging

# Configure logging
logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)


def get_sales_history(fecha_inicio=None, fecha_fin=None, limit=1000, offset=0):
    """
    Obtiene el historial de ventas con soporte para filtrado y paginaci√≥n.
    
    Args:
        fecha_inicio (str): Fecha en formato 'YYYY-MM-DD'
        fecha_fin (str): Fecha en formato 'YYYY-MM-DD'
        limit (int): M√°ximo de registros (default: 1000)
        offset (int): Para paginaci√≥n (default: 0)
    
    Returns:
        tuple: (success: bool, data: list or str)
    """
    conn = None
    cursor = None

    try:
        conn = conectar()
        if not conn:
            return False, "‚ùå Error: No se pudo conectar a la base de datos."

        cursor = conn.cursor(dictionary=True)

        # Base query ‚Äî now includes cliente real si existe
        query = """
            SELECT 
                v.id AS venta_id,
                v.fecha_venta,
                p.nombre AS producto_nombre,
                v.cantidad,
                v.total,
                COALESCE(c.nombre, 'P√∫blico General') AS cliente_nombre,
                u.nombre AS usuario_nombre
            FROM ventas v
            INNER JOIN productos p ON v.producto_id = p.id
            INNER JOIN usuarios u ON v.usuario_id = u.id
            LEFT JOIN clientes c ON v.cliente_id = c.id
            WHERE 1=1
        """

        params = []

        # üîπ Filtro por rango de fechas
        if fecha_inicio:
            query += " AND v.fecha_venta >= %s"
            params.append(fecha_inicio)
        if fecha_fin:
            query += " AND v.fecha_venta < %s"
            params.append(f"{fecha_fin} 23:59:59")  # Incluir todo el d√≠a

        query += " ORDER BY v.fecha_venta DESC"

        # üîπ Paginaci√≥n (protecci√≥n contra OOM)
        if limit is not None:
            query += " LIMIT %s"
            params.append(limit)
        if offset:
            query += " OFFSET %s"
            params.append(offset)

        cursor.execute(query, params)
        ventas = cursor.fetchall()

        return True, ventas

    except Exception as e:
        logger.exception("Error inesperado en get_sales_history")
        return False, f"‚ùå Error al cargar el historial: {str(e)}"
    finally:
        # ‚úÖ Cierre seguro: solo si existen y est√°n abiertos
        if cursor:
            try:
                cursor.close()
            except:
                pass
        if conn and conn.is_connected():
            try:
                conn.close()
            except:
                pass


# =================================================================
# UTILS: Funciones auxiliares para la vista
# =================================================================

def get_sales_summary(fecha_inicio=None, fecha_fin=None):
    """Obtiene resumen: total ventas, productos vendidos, etc."""
    conn = None
    cursor = None
    try:
        conn = conectar()
        if not conn:
            return False, "Error de conexi√≥n"

        cursor = conn.cursor(dictionary=True)
        query = """
            SELECT 
                COUNT(*) AS total_ventas,
                SUM(cantidad) AS total_productos,
                SUM(total) AS total_recaudado,
                AVG(total) AS promedio_venta
            FROM ventas v
            WHERE 1=1
        """
        params = []
        if fecha_inicio:
            query += " AND v.fecha_venta >= %s"
            params.append(fecha_inicio)
        if fecha_fin:
            query += " AND v.fecha_venta <= %s"
            params.append(f"{fecha_fin} 23:59:59")

        cursor.execute(query, params)
        resumen = cursor.fetchone()
        return True, resumen or {
            'total_ventas': 0,
            'total_productos': 0,
            'total_recaudado': 0.0,
            'promedio_venta': 0.0
        }
    except Exception as e:
        logger.error(f"Error en get_sales_summary: {e}")
        return False, str(e)
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()


# =================================================================
# PARA USO INMEDIATO (backwards compatible)
# =================================================================

def get_sales_history_simple():
    """Versi√≥n simple para compatibilidad con tu vista actual."""
    # Por defecto: √∫ltimos 30 d√≠as, m√°ximo 1000 registros
    hoy = datetime.now().date()
    hace_30 = hoy - timedelta(days=30)
    
    return get_sales_history(
        fecha_inicio=hace_30.strftime('%Y-%m-%d'),
        fecha_fin=hoy.strftime('%Y-%m-%d'),
        limit=1000
    )





#sales_history_view.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from export_controller import exportar_a_csv, generar_ruta_csv
from sales_history_controller import get_sales_history
from datetime import datetime
import threading


class SalesHistoryView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üìú Historial de Ventas")
        self.root.geometry("1150x700")
        self.root.configure(bg="#f5f7fa")

        # Estado de exportaci√≥n
        self.export_button = None

        # --- Estilos ---
        style = ttk.Style()
        style.configure("T.Green.TButton", background="#2ecc71", foreground="white", font=("Arial", 10, "bold"))
        style.configure("Treeview.Heading", font=("Arial", 11, "bold"), background="#d3e0e7")
        style.configure("Treeview", font=("Arial", 10), rowheight=25)

        # --- Barra superior ---
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üìú Historial de Ventas", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(root, text="‚Üê Volver al Dashboard", command=self.back_to_dashboard, bg="#6c757d", fg="white", font=("Arial", 10)).pack(anchor="nw", padx=20, pady=10)

        # --- Frame principal ---
        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # --- Barra de acciones ---
        action_frame = tk.Frame(main_frame, bg="#f5f7fa")
        action_frame.pack(fill="x", pady=5)

        self.export_button = ttk.Button(
            action_frame,
            text="üìÑ Exportar a CSV",
            command=self.exportar_historial,
            style="T.Green.TButton"
        )
        self.export_button.pack(side="left", padx=5)

        # Mensaje de carga (invisible al inicio)
        self.loading_label = tk.Label(action_frame, text="‚è≥ Cargando...", fg="#e74c3c", bg="#f5f7fa", font=("Arial", 10))
        self.loading_label.pack(side="left", padx=10)
        self.loading_label.pack_forget()  # Ocultar inicialmente

        # --- Tabla de ventas ---
        columns = ("ID Venta", "Fecha", "Producto", "Cantidad", "Total", "Cliente", "Vendedor")
        self.tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=20)

        for col in columns:
            self.tree.heading(col, text=col)
            width = 120
            anchor = "center"
            if col == "Producto":
                width = 250
                anchor = "w"
            elif col == "Total":
                width = 100
                anchor = "e"
            elif col == "Fecha":
                width = 160
            self.tree.column(col, width=width, anchor=anchor)

        # Scrollbars
        vsb = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        self.tree.pack(side="left", fill="both", expand=True)
        vsb.pack(side="right", fill="y")
        hsb.pack(side="bottom", fill="x")

        # Etiqueta de estado vac√≠o
        self.empty_label = tk.Label(main_frame, text="üîç No hay ventas registradas a√∫n.", 
                                   bg="#f5f7fa", fg="#7f8c8d", font=("Arial", 12, "italic"))
        self.empty_label.pack_forget()  # Ocultar inicialmente

        # Cargar datos
        self.load_history()

    def show_loading(self, show=True):
        """Muestra u oculta el indicador de carga."""
        if show:
            self.loading_label.pack(side="left", padx=10)
            self.root.update_idletasks()
        else:
            self.loading_label.pack_forget()

    def load_history(self):
        self.show_loading(True)
        try:
            success, data = get_sales_history()

            # Limpiar tabla
            for item in self.tree.get_children():
                self.tree.delete(item)

            if success and data:
                # Ocultar mensaje vac√≠o, mostrar tabla
                self.empty_label.pack_forget()
                for venta in data:
                    self.tree.insert("", "end", values=(
                        venta.get('venta_id', '‚Äî'),
                        venta.get('fecha_venta', '‚Äî'),
                        venta.get('producto_nombre', '‚Äî'),
                        venta.get('cantidad', 0),
                        f"${venta.get('total', 0):.2f}",
                        venta.get('cliente_nombre', 'N/A'),
                        venta.get('usuario_nombre', '‚Äî')
                    ))
            else:
                # Mostrar mensaje vac√≠o
                self.tree.pack_forget()
                self.empty_label.pack(pady=40)
                if not success:
                    messagebox.showwarning("‚ö†Ô∏è Advertencia", f"No se pudo cargar el historial:\n{data}", parent=self.root)
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Error al cargar historial:\n{e}", parent=self.root)
            self.empty_label.config(text="‚ùå Error al cargar los datos.")
            self.empty_label.pack(pady=40)
        finally:
            self.show_loading(False)

    def exportar_historial(self):
        # üîí Prevenir m√∫ltiples clics
        self.export_button.config(state="disabled")
        self.root.update_idletasks()

        try:
            success, data = get_sales_history()

            if not success:
                messagebox.showerror("‚ùå Error", f"No se pudo obtener los datos:\n{data}", parent=self.root)
                return

            if not data:
                messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", "No hay ventas para exportar.", parent=self.root)
                return

            # ‚úÖ Validar que data no est√© vac√≠o antes de acceder a [0]
            try:
                raw_keys = list(data[0].keys())
            except (IndexError, TypeError):
                messagebox.showwarning("‚ö†Ô∏è Advertencia", "Datos inv√°lidos para exportar.", parent=self.root)
                return

            # Generar ruta sugerida con fecha
            fecha_hoy = datetime.now().strftime("%Y%m%d")
            nombre_archivo = f"Ventas_{fecha_hoy}.csv"
            ruta_sugerida = generar_ruta_csv(nombre_archivo)

            ruta_guardado = filedialog.asksaveasfilename(
                title="Guardar Reporte de Ventas",
                defaultextension=".csv",
                initialfile=ruta_sugerida,
                filetypes=[("Archivos CSV", "*.csv"), ("Todos los archivos", "*.*")]
            )

            if not ruta_guardado:
                return  # Cancelado por usuario

            # ‚úÖ Exportar (en segundo plano si es lento)
            exito, mensaje = exportar_a_csv(data, ruta_guardado, raw_keys)

            if exito:
                messagebox.showinfo("‚úÖ √âxito", f"Reporte exportado correctamente:\n{ruta_guardado}", parent=self.root)
            else:
                messagebox.showerror("‚ùå Error", f"No se pudo exportar:\n{mensaje}", parent=self.root)

        except Exception as e:
            messagebox.showerror("‚ùå Error Fatal", f"Error inesperado al exportar:\n{e}", parent=self.root)
        finally:
            self.export_button.config(state="normal")

    def back_to_dashboard(self):
        self.root.destroy()
        try:
            from dashboard_view import DashboardView
            root = tk.Tk()
            DashboardView(root, self.usuario)
            root.mainloop()
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"No se pudo abrir el dashboard:\n{e}")





            # suppliers_controller.py
from database import conectar

def obtener_todos_proveedores():
    conn = conectar()
    if not conn:
        return []
    
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT * FROM proveedores ORDER BY nombre_empresa ASC")
    proveedores = cursor.fetchall()
    cursor.close()
    conn.close()
    return proveedores

def agregar_proveedor(nombre_empresa, contacto, telefono, correo, direccion):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n a la base de datos"
    
    cursor = conn.cursor()
    try:
        query = """
        INSERT INTO proveedores (nombre_empresa, contacto, telefono, correo, direccion)
        VALUES (%s, %s, %s, %s, %s)
        """
        cursor.execute(query, (nombre_empresa, contacto, telefono, correo, direccion))
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Proveedor agregado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al agregar proveedor: {str(e)}"

def actualizar_proveedor(id_proveedor, nombre_empresa, contacto, telefono, correo, direccion):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor()
    try:
        query = """
        UPDATE proveedores 
        SET nombre_empresa=%s, contacto=%s, telefono=%s, correo=%s, direccion=%s
        WHERE id=%s
        """
        cursor.execute(query, (nombre_empresa, contacto, telefono, correo, direccion, id_proveedor))
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Proveedor actualizado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al actualizar: {str(e)}"

def eliminar_proveedor(id_proveedor):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor()
    try:
      
        cursor.execute("SELECT COUNT(*) AS total FROM productos WHERE proveedor_id = %s", (id_proveedor,))
        resultado = cursor.fetchone()
        if resultado['total'] > 0:
            return False, "No se puede eliminar: hay productos asociados a este proveedor."
        
        cursor.execute("DELETE FROM proveedores WHERE id = %s", (id_proveedor,))
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Proveedor eliminado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al eliminar: {str(e)}"
    



    # suppliers_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from suppliers_controller import obtener_todos_proveedores, agregar_proveedor, actualizar_proveedor, eliminar_proveedor

class ProveedoresView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üè≠ Gesti√≥n de Proveedores - Papeler√≠a √Ångel")
        self.root.geometry("1100x650")
        self.root.configure(bg="#f5f7fa")

        # Barra superior
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üè≠ Gesti√≥n de Proveedores", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(
            top_bar,
            text="üö™ Cerrar Sesi√≥n",
            command=self.confirmar_cierre,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief="flat",
            padx=10
        ).pack(side="right", padx=20, pady=10)

        back_btn = tk.Button(root, text="‚Üê Volver al Dashboard", command=self.volver_dashboard, bg="#6c757d", fg="white", font=("Arial", 10))
        back_btn.pack(anchor="nw", padx=20, pady=10)

        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # Formulario
        form_frame = tk.LabelFrame(main_frame, text="Agregar Nuevo Proveedor", font=("Arial", 12, "bold"), bg="#f5f7fa", padx=15, pady=15)
        form_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)

        tk.Label(form_frame, text="Nombre Empresa:", bg="#f5f7fa", font=("Arial", 11)).grid(row=0, column=0, sticky="w", pady=5)
        self.nombre_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.nombre_entry.grid(row=0, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Contacto:", bg="#f5f7fa", font=("Arial", 11)).grid(row=1, column=0, sticky="w", pady=5)
        self.contacto_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.contacto_entry.grid(row=1, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Tel√©fono:", bg="#f5f7fa", font=("Arial", 11)).grid(row=2, column=0, sticky="w", pady=5)
        self.telefono_entry = tk.Entry(form_frame, font=("Arial", 12), width=20, relief="solid", bd=1)
        self.telefono_entry.grid(row=2, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Correo:", bg="#f5f7fa", font=("Arial", 11)).grid(row=3, column=0, sticky="w", pady=5)
        self.correo_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.correo_entry.grid(row=3, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Direcci√≥n:", bg="#f5f7fa", font=("Arial", 11)).grid(row=4, column=0, sticky="w", pady=5)
        self.direccion_entry = tk.Entry(form_frame, font=("Arial", 12), width=40, relief="solid", bd=1)
        self.direccion_entry.grid(row=4, column=1, padx=10, pady=5)

        btn_agregar = tk.Button(form_frame, text="‚ûï Agregar Proveedor", command=self.agregar_proveedor, bg="#2ecc71", fg="white", font=("Arial", 12, "bold"))
        btn_agregar.grid(row=5, column=0, columnspan=2, pady=15)

        # Tabla
        table_frame = tk.LabelFrame(main_frame, text="Lista de Proveedores", font=("Arial", 12, "bold"), bg="#f5f7fa", padx=15, pady=15)
        table_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

        columns = ("ID", "Empresa", "Contacto", "Tel√©fono", "Correo", "Editar", "Eliminar")
        self.tree = ttk.Treeview(table_frame, columns=columns, show="headings", height=12)

        for col in columns:
            self.tree.heading(col, text=col)
            if col == "Correo":
                self.tree.column(col, width=150, anchor="w")
            elif col in ("Editar", "Eliminar"):
                self.tree.column(col, width=60, anchor="center")
            else:
                self.tree.column(col, width=120, anchor="w")

        self.tree.pack(fill="both", expand=True)

        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")

        # Vincular clic
        self.tree.bind("<ButtonRelease-1>", self.on_tree_click)

        # Bot√≥n de acci√≥n
        btn_frame = tk.Frame(table_frame, bg="#f5f7fa")
        btn_frame.pack(pady=10)
        tk.Button(btn_frame, text="üîÑ Actualizar", command=self.cargar_proveedores, bg="#3498db", fg="white", font=("Arial", 11)).pack(side="left", padx=5)

        self.cargar_proveedores()

    def on_tree_click(self, event):
        region = self.tree.identify("region", event.x, event.y)
        if region == "cell":
            column = self.tree.identify_column(event.x)
            item = self.tree.identify_row(event.y)
            if item and column in ("#6", "#7"):
                values = self.tree.item(item, "values")
                proveedor_id = values[0]
                if column == "#6":
                    self.editar_directo(proveedor_id)
                elif column == "#7":
                    self.eliminar_directo(proveedor_id)

    def cargar_proveedores(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
        proveedores = obtener_todos_proveedores()
        for p in proveedores:
            self.tree.insert("", "end", values=(
                p['id'], p['nombre_empresa'], p['contacto'], p['telefono'], p['correo'], "‚úèÔ∏è", "üóëÔ∏è"
            ))

    def agregar_proveedor(self):
        nombre = self.nombre_entry.get().strip()
        contacto = self.contacto_entry.get().strip()
        telefono = self.telefono_entry.get().strip()
        correo = self.correo_entry.get().strip()
        direccion = self.direccion_entry.get().strip()

        if not nombre or not contacto:
            messagebox.showwarning("‚ö†Ô∏è Campos obligatorios", "Nombre de empresa y contacto son obligatorios.")
            return

        if "@" not in correo or "." not in correo:
            messagebox.showwarning("‚ö†Ô∏è Correo inv√°lido", "El correo debe tener un formato v√°lido (ej. usuario@dominio.com).")
            return

        exito, mensaje = agregar_proveedor(nombre, contacto, telefono, correo, direccion)
        if exito:
            messagebox.showinfo("‚úÖ √âxito", mensaje)
            self.limpiar_formulario()
            self.cargar_proveedores()
        else:
            messagebox.showerror("‚ùå Error", mensaje)

    def limpiar_formulario(self):
        self.nombre_entry.delete(0, tk.END)
        self.contacto_entry.delete(0, tk.END)
        self.telefono_entry.delete(0, tk.END)
        self.correo_entry.delete(0, tk.END)
        self.direccion_entry.delete(0, tk.END)

    def editar_directo(self, proveedor_id):
        proveedores = obtener_todos_proveedores()
        proveedor = next((p for p in proveedores if str(p['id']) == str(proveedor_id)), None)
        if not proveedor:
            messagebox.showerror("‚ùå Error", "Proveedor no encontrado.")
            return

        edit_window = tk.Toplevel(self.root)
        edit_window.title(f"Editar Proveedor ID: {proveedor_id}")
        edit_window.geometry("450x450")
        edit_window.configure(bg="#f5f7fa")

        tk.Label(edit_window, text=f"Editar Proveedor: {proveedor['nombre_empresa']}", font=("Arial", 16, "bold"), bg="#f5f7fa").pack(pady=15)

        form = tk.Frame(edit_window, bg="#f5f7fa")
        form.pack(padx=20, pady=10)

        tk.Label(form, text="Nombre Empresa:", bg="#f5f7fa", font=("Arial", 11)).grid(row=0, column=0, sticky="w", pady=5)
        nombre_entry = tk.Entry(form, font=("Arial", 12), width=30, relief="solid", bd=1)
        nombre_entry.insert(0, proveedor['nombre_empresa'])
        nombre_entry.grid(row=0, column=1, padx=10, pady=5)

        tk.Label(form, text="Contacto:", bg="#f5f7fa", font=("Arial", 11)).grid(row=1, column=0, sticky="w", pady=5)
        contacto_entry = tk.Entry(form, font=("Arial", 12), width=30, relief="solid", bd=1)
        contacto_entry.insert(0, proveedor['contacto'])
        contacto_entry.grid(row=1, column=1, padx=10, pady=5)

        tk.Label(form, text="Tel√©fono:", bg="#f5f7fa", font=("Arial", 11)).grid(row=2, column=0, sticky="w", pady=5)
        tel_entry = tk.Entry(form, font=("Arial", 12), width=20, relief="solid", bd=1)
        tel_entry.insert(0, proveedor['telefono'])
        tel_entry.grid(row=2, column=1, padx=10, pady=5)

        tk.Label(form, text="Correo:", bg="#f5f7fa", font=("Arial", 11)).grid(row=3, column=0, sticky="w", pady=5)
        correo_entry = tk.Entry(form, font=("Arial", 12), width=30, relief="solid", bd=1)
        correo_entry.insert(0, proveedor['correo'])
        correo_entry.grid(row=3, column=1, padx=10, pady=5)

        tk.Label(form, text="Direcci√≥n:", bg="#f5f7fa", font=("Arial", 11)).grid(row=4, column=0, sticky="w", pady=5)
        direc_entry = tk.Entry(form, font=("Arial", 12), width=40, relief="solid", bd=1)
        direc_entry.insert(0, proveedor.get('direccion', ''))
        direc_entry.grid(row=4, column=1, padx=10, pady=5)

        def guardar():
            nombre = nombre_entry.get().strip()
            contacto = contacto_entry.get().strip()
            tel = tel_entry.get().strip()
            correo = correo_entry.get().strip()
            direc = direc_entry.get().strip()

            if not nombre or not contacto:
                messagebox.showwarning("‚ö†Ô∏è Campos obligatorios", "Nombre y contacto son obligatorios.", parent=edit_window)
                return

            if "@" not in correo or "." not in correo:
                messagebox.showwarning("‚ö†Ô∏è Correo inv√°lido", "El correo debe tener un formato v√°lido.", parent=edit_window)
                return

            exito, msg = actualizar_proveedor(proveedor_id, nombre, contacto, tel, correo, direc)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", "Proveedor actualizado correctamente.", parent=edit_window)
                edit_window.destroy()
                self.cargar_proveedores()
            else:
                messagebox.showerror("‚ùå Error", msg, parent=edit_window)

        btn_frame = tk.Frame(edit_window, bg="#f5f7fa")
        btn_frame.pack(pady=20)
        tk.Button(btn_frame, text="Guardar Cambios", command=guardar, bg="#2ecc71", fg="white", font=("Arial", 12, "bold"), width=15).pack(side="left", padx=5)
        tk.Button(btn_frame, text="Cancelar", command=edit_window.destroy, bg="#e74c3c", fg="white", font=("Arial", 12, "bold"), width=10).pack(side="left", padx=5)

    def eliminar_directo(self, proveedor_id):
        if messagebox.askyesno(
            "‚ùì Confirmar eliminaci√≥n", 
            "¬øEst√° seguro de eliminar este proveedor?\n‚ö†Ô∏è Esto tambi√©n eliminar√° sus productos si no hay restricciones.",
            parent=self.root
        ):
            exito, mensaje = eliminar_proveedor(proveedor_id)
            if exito:
                messagebox.showinfo("‚úÖ √âxito", mensaje, parent=self.root)
                self.cargar_proveedores()
            else:
                messagebox.showerror("‚ùå Error", mensaje, parent=self.root)
        else:
            messagebox.showinfo("‚ÑπÔ∏è Cancelado", "No se ha eliminado ning√∫n proveedor.", parent=self.root)

    def volver_dashboard(self):
        self.root.destroy()
        from dashboard_view import DashboardView
        nueva_ventana = tk.Tk()
        DashboardView(nueva_ventana, self.usuario)
        nueva_ventana.mainloop()

    def confirmar_cierre(self):
        if messagebox.askyesno("‚ùì Cerrar sesi√≥n", f"¬øEst√° seguro que desea cerrar sesi√≥n como {self.usuario['nombre']}?"):
            self.root.destroy()
            from login import LoginView
            root = tk.Tk()
            LoginView(root)
            root.mainloop()
        else:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", "Se ha cancelado el cierre de sesi√≥n.")




            # user_controller.py
from database import conectar
import hashlib

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def get_all_users():
    conn = conectar()
    if not conn:
        return []
    
    cursor = conn.cursor(dictionary=True)
    query = "SELECT * FROM usuarios ORDER BY nombre ASC"
    cursor.execute(query)
    usuarios = cursor.fetchall()
    cursor.close()
    conn.close()
    return usuarios

def add_user(nombre, correo, contrase√±a, rol="cajero"):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor()
    hashed_pass = hash_password(contrase√±a)
    
    query = """
    INSERT INTO usuarios (nombre, correo, contrase√±a, rol)
    VALUES (%s, %s, %s, %s)
    """
    try:
        cursor.execute(query, (nombre, correo, hashed_pass, rol))
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Usuario registrado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al registrar: {str(e)}"

def update_user(user_id, nombre, correo, rol, nueva_contrase√±a=None):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor()
    if nueva_contrase√±a:
        hashed_pass = hash_password(nueva_contrase√±a)
        query = "UPDATE usuarios SET nombre=%s, correo=%s, contrase√±a=%s, rol=%s WHERE id=%s"
        params = (nombre, correo, hashed_pass, rol, user_id)
    else:
        query = "UPDATE usuarios SET nombre=%s, correo=%s, rol=%s WHERE id=%s"
        params = (nombre, correo, rol, user_id)
    
    try:
        cursor.execute(query, params)
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Usuario actualizado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al actualizar: {str(e)}"

def delete_user(user_id):
    conn = conectar()
    if not conn:
        return False, "Error de conexi√≥n"
    
    cursor = conn.cursor()
    query = "DELETE FROM usuarios WHERE id=%s"
    try:
        cursor.execute(query, (user_id,))
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Usuario eliminado exitosamente"
    except Exception as e:
        conn.rollback()
        cursor.close()
        conn.close()
        return False, f"Error al eliminar: {str(e)}"
    



    # user_view.py
import tkinter as tk
from tkinter import ttk, messagebox
from user_controller import get_all_users, add_user, update_user, delete_user

class UserView:
    def __init__(self, root, usuario):
        self.root = root
        self.usuario = usuario
        self.root.title("üë• Gesti√≥n de Usuarios - Papeler√≠a √Ångel")
        self.root.geometry("1050x650")
        self.root.configure(bg="#f5f7fa")

        # Barra superior
        top_bar = tk.Frame(root, bg="#2c3e50", height=60)
        top_bar.pack(fill="x")
        tk.Label(top_bar, text="üë• Gesti√≥n de Usuarios", font=("Arial", 18, "bold"), fg="white", bg="#2c3e50").pack(side="left", padx=20, pady=10)
        tk.Button(
            top_bar,
            text="üö™ Cerrar Sesi√≥n",
            command=self.confirmar_cierre,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 10, "bold"),
            relief="flat",
            padx=10
        ).pack(side="right", padx=20, pady=10)

        back_btn = tk.Button(root, text="‚Üê Volver al Dashboard", command=self.back_to_dashboard, bg="#6c757d", fg="white", font=("Arial", 10))
        back_btn.pack(anchor="nw", padx=20, pady=10)

        main_frame = tk.Frame(root, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # Formulario
        form_frame = tk.LabelFrame(main_frame, text="Agregar Nuevo Usuario", font=("Arial", 12, "bold"), bg="#f5f7fa", padx=15, pady=15)
        form_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)

        tk.Label(form_frame, text="Nombre:", bg="#f5f7fa", font=("Arial", 11)).grid(row=0, column=0, sticky="w", pady=5)
        self.name_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.name_entry.grid(row=0, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Correo:", bg="#f5f7fa", font=("Arial", 11)).grid(row=1, column=0, sticky="w", pady=5)
        self.email_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1)
        self.email_entry.grid(row=1, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Contrase√±a:", bg="#f5f7fa", font=("Arial", 11)).grid(row=2, column=0, sticky="w", pady=5)
        self.password_entry = tk.Entry(form_frame, font=("Arial", 12), width=30, relief="solid", bd=1, show="*")
        self.password_entry.grid(row=2, column=1, padx=10, pady=5)

        tk.Label(form_frame, text="Rol:", bg="#f5f7fa", font=("Arial", 11)).grid(row=3, column=0, sticky="w", pady=5)
        self.role_var = tk.StringVar(value="cajero")
        self.role_combo = ttk.Combobox(form_frame, textvariable=self.role_var, values=["admin", "cajero"], state="readonly", width=28)
        self.role_combo.grid(row=3, column=1, padx=10, pady=5)

        add_btn = tk.Button(form_frame, text="‚ûï Agregar Usuario", command=self.add_user, bg="#2ecc71", fg="white", font=("Arial", 12, "bold"))
        add_btn.grid(row=4, column=0, columnspan=2, pady=15)

        # Tabla
        table_frame = tk.LabelFrame(main_frame, text="Lista de Usuarios", font=("Arial", 12, "bold"), bg="#f5f7fa", padx=15, pady=15)
        table_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

        columns = ("ID", "Nombre", "Correo", "Rol", "Fecha Registro", "Editar", "Eliminar")
        self.tree = ttk.Treeview(table_frame, columns=columns, show="headings", height=15)

        for col in columns:
            self.tree.heading(col, text=col)
            if col == "Correo":
                self.tree.column(col, width=200, anchor="w")
            elif col in ("Editar", "Eliminar"):
                self.tree.column(col, width=60, anchor="center")
            else:
                self.tree.column(col, width=120, anchor="w")

        self.tree.pack(fill="both", expand=True)

        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")

        # Vincular clic
        self.tree.bind("<ButtonRelease-1>", self.on_tree_click)

        # Bot√≥n de acci√≥n
        btn_frame = tk.Frame(table_frame, bg="#f5f7fa")
        btn_frame.pack(pady=10)
        tk.Button(btn_frame, text="üîÑ Actualizar", command=self.load_users, bg="#3498db", fg="white", font=("Arial", 11)).pack(side="left", padx=5)

        self.load_users()

    def on_tree_click(self, event):
        region = self.tree.identify("region", event.x, event.y)
        if region == "cell":
            column = self.tree.identify_column(event.x)
            item = self.tree.identify_row(event.y)
            if item and column in ("#6", "#7"):
                values = self.tree.item(item, "values")
                user_id = values[0]
                if column == "#6":
                    self.editar_directo(user_id)
                elif column == "#7":
                    self.eliminar_directo(user_id)

    def load_users(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
        usuarios = get_all_users()
        for u in usuarios:
            self.tree.insert("", "end", values=(
                u['id'], u['nombre'], u['correo'], u['rol'], u['fecha_registro'], "‚úèÔ∏è", "üóëÔ∏è"
            ))

    def add_user(self):
        nombre = self.name_entry.get().strip()
        correo = self.email_entry.get().strip()
        contrase√±a = self.password_entry.get().strip()
        rol = self.role_var.get()

        if not nombre or not correo or not contrase√±a:
            messagebox.showwarning("‚ö†Ô∏è Campos obligatorios", "Todos los campos son obligatorios.")
            return

        if "@" not in correo or "." not in correo:
            messagebox.showwarning("‚ö†Ô∏è Correo inv√°lido", "El correo debe tener un formato v√°lido.")
            return

        if len(contrase√±a) < 6:
            messagebox.showwarning("‚ö†Ô∏è Contrase√±a d√©bil", "La contrase√±a debe tener al menos 6 caracteres.")
            return

        success, msg = add_user(nombre, correo, contrase√±a, rol)
        if success:
            messagebox.showinfo("‚úÖ √âxito", msg)
            self.clear_form()
            self.load_users()
        else:
            messagebox.showerror("‚ùå Error", msg)

    def clear_form(self):
        self.name_entry.delete(0, tk.END)
        self.email_entry.delete(0, tk.END)
        self.password_entry.delete(0, tk.END)
        self.role_var.set("cajero")

    def editar_directo(self, user_id):
        usuarios = get_all_users()
        usuario = next((u for u in usuarios if str(u['id']) == str(user_id)), None)
        if not usuario:
            messagebox.showerror("‚ùå Error", "Usuario no encontrado.")
            return

        edit_window = tk.Toplevel(self.root)
        edit_window.title(f"Editar Usuario ID: {user_id}")
        edit_window.geometry("420x420")
        edit_window.configure(bg="#f5f7fa")

        tk.Label(edit_window, text=f"Editar Usuario: {usuario['nombre']}", font=("Arial", 16, "bold"), bg="#f5f7fa").pack(pady=15)

        form_edit = tk.Frame(edit_window, bg="#f5f7fa")
        form_edit.pack(padx=20, pady=10)

        tk.Label(form_edit, text="Nombre:", bg="#f5f7fa", font=("Arial", 11)).grid(row=0, column=0, sticky="w", pady=5)
        name_entry = tk.Entry(form_edit, font=("Arial", 12), width=30, relief="solid", bd=1)
        name_entry.insert(0, usuario['nombre'])
        name_entry.grid(row=0, column=1, padx=10, pady=5)

        tk.Label(form_edit, text="Correo:", bg="#f5f7fa", font=("Arial", 11)).grid(row=1, column=0, sticky="w", pady=5)
        email_entry = tk.Entry(form_edit, font=("Arial", 12), width=30, relief="solid", bd=1)
        email_entry.insert(0, usuario['correo'])
        email_entry.grid(row=1, column=1, padx=10, pady=5)

        tk.Label(form_edit, text="Rol:", bg="#f5f7fa", font=("Arial", 11)).grid(row=2, column=0, sticky="w", pady=5)
        role_var = tk.StringVar(value=usuario['rol'])
        role_combo = ttk.Combobox(form_edit, textvariable=role_var, values=["admin", "cajero"], state="readonly", width=28)
        role_combo.grid(row=2, column=1, padx=10, pady=5)

        tk.Label(form_edit, text="Nueva Contrase√±a (opcional):", bg="#f5f7fa", font=("Arial", 11)).grid(row=3, column=0, sticky="w", pady=5)
        new_pass_entry = tk.Entry(form_edit, font=("Arial", 12), width=30, relief="solid", bd=1, show="*")
        new_pass_entry.grid(row=3, column=1, padx=10, pady=5)

        def save_changes():
            nombre = name_entry.get().strip()
            correo = email_entry.get().strip()
            rol = role_var.get()
            nueva_contrase√±a = new_pass_entry.get().strip()

            if not nombre or not correo:
                messagebox.showwarning("‚ö†Ô∏è Campos obligatorios", "Nombre y correo son obligatorios.", parent=edit_window)
                return

            if "@" not in correo or "." not in correo:
                messagebox.showwarning("‚ö†Ô∏è Correo inv√°lido", "El correo debe tener un formato v√°lido.", parent=edit_window)
                return

            success, msg = update_user(user_id, nombre, correo, rol, nueva_contrase√±a if nueva_contrase√±a else None)
            if success:
                messagebox.showinfo("‚úÖ √âxito", "Usuario actualizado correctamente.", parent=edit_window)
                edit_window.destroy()
                self.load_users()
            else:
                messagebox.showerror("‚ùå Error", msg, parent=edit_window)

        btn_frame = tk.Frame(edit_window, bg="#f5f7fa")
        btn_frame.pack(pady=20)
        tk.Button(btn_frame, text="Guardar Cambios", command=save_changes, bg="#2ecc71", fg="white", font=("Arial", 12, "bold"), width=15).pack(side="left", padx=5)
        tk.Button(btn_frame, text="Cancelar", command=edit_window.destroy, bg="#e74c3c", fg="white", font=("Arial", 12, "bold"), width=10).pack(side="left", padx=5)

    def eliminar_directo(self, user_id):
        if user_id == str(self.usuario['id']):
            messagebox.showwarning("‚ö†Ô∏è Acci√≥n no permitida", "No puedes eliminar tu propia cuenta.", parent=self.root)
            return

        if messagebox.askyesno(
            "‚ùì Confirmar eliminaci√≥n", 
            "¬øEst√° seguro de eliminar este usuario?\n‚ö†Ô∏è Esta acci√≥n es irreversible.",
            parent=self.root
        ):
            success, msg = delete_user(user_id)
            if success:
                messagebox.showinfo("‚úÖ √âxito", "Usuario eliminado correctamente.", parent=self.root)
                self.load_users()
            else:
                messagebox.showerror("‚ùå Error", msg, parent=self.root)
        else:
            messagebox.showinfo("‚ÑπÔ∏è Cancelado", "No se ha eliminado ning√∫n usuario.", parent=self.root)

    def back_to_dashboard(self):
        self.root.destroy()
        from dashboard_view import DashboardView
        nueva_ventana = tk.Tk()
        DashboardView(nueva_ventana, self.usuario)
        nueva_ventana.mainloop()

    def confirmar_cierre(self):
        if messagebox.askyesno("‚ùì Cerrar sesi√≥n", f"¬øEst√° seguro que desea cerrar sesi√≥n como {self.usuario['nombre']}?"):
            self.root.destroy()
            from login import LoginView
            root = tk.Tk()
            LoginView(root)
            root.mainloop()
        else:
            messagebox.showinfo("‚ÑπÔ∏è Informaci√≥n", "Se ha cancelado el cierre de sesi√≥n.")
